// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// RCCStakeMetaData contains all meta data concerning the RCCStake contract.
var RCCStakeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ERC1967InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967NonPayable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"UUPSUnsupportedProxiableUUID\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolWeight\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minDepositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unstakeLockedBlocks\",\"type\":\"uint256\"}],\"name\":\"AddPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rccReward\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequestUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"SetEndBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPoolWeight\",\"type\":\"uint256\"}],\"name\":\"SetPoolWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contractIERC20\",\"name\":\"RCC\",\"type\":\"address\"}],\"name\":\"SetRCC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rccPerBlock\",\"type\":\"uint256\"}],\"name\":\"SetRCCPerBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"SetStartBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnpauseClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnpauseWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalRCC\",\"type\":\"uint256\"}],\"name\":\"UpdatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"minDepositAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"unstakeLockedBlocks\",\"type\":\"uint256\"}],\"name\":\"UpdatePoolInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_PID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RCC\",\"outputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPGRADE_INTERFACE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPGRADE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unstakeLockedBlocks\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"_RCC\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rccPerBlock\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingRCC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"pendingRCCByBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRCCPerST\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeLockedBlocks\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rccPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"setEndBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolWeight\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"setPoolWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"_RCC\",\"type\":\"address\"}],\"name\":\"setRCC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rccPerBlock\",\"type\":\"uint256\"}],\"name\":\"setRCCPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"stakingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unstakeLockedBlocks\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishedRCC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRCC\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"withdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdrawAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x60a06040523060805234801561001457600080fd5b506080516137bc61003e60003960008181612810015281816128390152612a3501526137bc6000f3fe6080604052600436106102935760003560e01c806375b238fc1161015a578063bfc3ebba116100c1578063f35e4a6e1161007a578063f35e4a6e146107f4578063f5485d3214610814578063f6326fb314610834578063fad07ece1461083c578063fe3131121461085c578063ff423357146108bb57600080fd5b8063bfc3ebba1461063b578063c713aa941461075f578063d547741f1461077f578063d86c04441461079f578063de065caa146107bf578063e2bbb158146107d457600080fd5b8063a72d5bf411610113578063a72d5bf414610650578063ab5e124a1461068e578063ad3cb1cc146106ad578063b6d9d919146106eb578063b908afa81461070b578063bed66c081461073f57600080fd5b806375b238fc146105a45780638dbb1e3a146105c65780638ff095f9146105e657806391d14854146105fb5780639e2c8a5b1461061b578063a217fddf1461063b57600080fd5b80633b82783e116101fe57806352d1902d116101b757806352d1902d146105035780635bb6d007146105185780635c975abb1461052d5780636155e3de14610564578063630b5ba11461057957806370ff01731461058e57600080fd5b80633b82783e1461045a57806341721ab71461047a57806348cd4cb11461049a5780634ec81af1146104b05780634f1ef286146104d057806351eb05a6146104e357600080fd5b80632e1a7d4d116102505780632e1a7d4d1461035c5780632f2ff15d1461037e5780632f3ffb9f1461039e57806336568abe146103b857806337849b3c146103d8578063379607f51461043a57600080fd5b806301ffc9a71461029857806302559004146102cd578063081e3eda146102f1578063083c632314610306578063115482341461031c578063248a9ca31461033c575b600080fd5b3480156102a457600080fd5b506102b86102b33660046131c2565b6108f0565b60405190151581526020015b60405180910390f35b3480156102d957600080fd5b506102e360045481565b6040519081526020016102c4565b3480156102fd57600080fd5b506005546102e3565b34801561031257600080fd5b506102e360015481565b34801561032857600080fd5b506102e3610337366004613201565b610927565b34801561034857600080fd5b506102e3610357366004613231565b610983565b34801561036857600080fd5b5061037c610377366004613231565b6109a5565b005b34801561038a57600080fd5b5061037c610399366004613201565b610c48565b3480156103aa57600080fd5b506003546102b89060ff1681565b3480156103c457600080fd5b5061037c6103d3366004613201565b610c6a565b3480156103e457600080fd5b5061041f6103f3366004613201565b600660209081526000928352604080842090915290825290208054600182015460029092015490919083565b604080519384526020840192909252908201526060016102c4565b34801561044657600080fd5b5061037c610455366004613231565b610ca2565b34801561046657600080fd5b506102e3610475366004613201565b610e25565b34801561048657600080fd5b506102e361049536600461324a565b610e5e565b3480156104a657600080fd5b506102e360005481565b3480156104bc57600080fd5b5061037c6104cb366004613282565b610f9a565b61037c6104de3660046132d3565b61116d565b3480156104ef57600080fd5b5061037c6104fe366004613231565b61118c565b34801561050f57600080fd5b506102e361134b565b34801561052457600080fd5b5061037c611368565b34801561053957600080fd5b507fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033005460ff166102b8565b34801561057057600080fd5b5061037c611413565b34801561058557600080fd5b5061037c6114b7565b34801561059a57600080fd5b506102e360025481565b3480156105b057600080fd5b506102e360008051602061372783398151915281565b3480156105d257600080fd5b506102e36105e1366004613397565b6114e0565b3480156105f257600080fd5b5061037c611600565b34801561060757600080fd5b506102b8610616366004613201565b6116ab565b34801561062757600080fd5b5061037c610636366004613397565b6116e3565b34801561064757600080fd5b506102e3600081565b34801561065c57600080fd5b50600354610676906201000090046001600160a01b031681565b6040516001600160a01b0390911681526020016102c4565b34801561069a57600080fd5b506003546102b890610100900460ff1681565b3480156106b957600080fd5b506106de604051806040016040528060058152602001640352e302e360dc1b81525081565b6040516102c491906133dd565b3480156106f757600080fd5b5061037c61070636600461341e565b61191b565b34801561071757600080fd5b506102e37fcab03bc4dbcc648cd59d6bbe9f848d1e9092f914016aa290ee92e18700d1e6f981565b34801561074b57600080fd5b5061037c61075a366004613231565b611c0d565b34801561076b57600080fd5b5061037c61077a366004613231565b611c9d565b34801561078b57600080fd5b5061037c61079a366004613201565b611d0b565b3480156107ab57600080fd5b5061037c6107ba366004613474565b611d27565b3480156107cb57600080fd5b5061037c611dea565b3480156107e057600080fd5b5061037c6107ef366004613397565b611e90565b34801561080057600080fd5b5061037c61080f366004613231565b611faa565b34801561082057600080fd5b5061037c61082f3660046134a0565b612015565b61037c612087565b34801561084857600080fd5b5061037c6108573660046134bd565b612141565b34801561086857600080fd5b5061087c610877366004613231565b612271565b604080516001600160a01b0390981688526020880196909652948601939093526060850191909152608084015260a083015260c082015260e0016102c4565b3480156108c757600080fd5b506108db6108d6366004613201565b6122ca565b604080519283526020830191909152016102c4565b60006001600160e01b03198216637965db0b60e01b148061092157506301ffc9a760e01b6001600160e01b03198316145b92915050565b600554600090839081106109565760405162461bcd60e51b815260040161094d906134f6565b60405180910390fd5b60008481526006602090815260408083206001600160a01b038716845290915290205491505b5092915050565b6000908152600080516020613767833981519152602052604090206001015490565b6109ad6123d4565b600554819081106109d05760405162461bcd60e51b815260040161094d906134f6565b60035460ff1615610a185760405162461bcd60e51b81526020600482015260126024820152711dda5d1a191c985dc81a5cc81c185d5cd95960721b604482015260640161094d565b600060058381548110610a2d57610a2d61351b565b6000918252602080832086845260068252604080852033865290925290832060079092020192509080805b6003840154811015610ae55743846003018281548110610a7a57610a7a61351b565b90600052602060002090600202016001015411610ae557836003018181548110610aa657610aa661351b565b90600052602060002090600202016000015483610ac39190613547565b925081610acf8161355a565b9250508080610add9061355a565b915050610a58565b5060005b6003840154610af9908390613573565b811015610b715760038401610b0e8383613547565b81548110610b1e57610b1e61351b565b9060005260206000209060020201846003018281548110610b4157610b4161351b565b60009182526020909120825460029092020190815560019182015491015580610b698161355a565b915050610ae9565b5060005b81811015610bc05783600301805480610b9057610b90613586565b60008281526020812060026000199093019283020181815560010155905580610bb88161355a565b915050610b75565b508115610bfb5783546001600160a01b0316610be557610be03383612419565b610bfb565b8354610bfb906001600160a01b03163384612534565b4386336001600160a01b03167f02f25270a4d87bea75db541cdfe559334a275b4a233520ed6c0a2429667cca9485604051610c3891815260200190565b60405180910390a4505050505050565b610c5182610983565b610c5a81612593565b610c6483836125a0565b50505050565b6001600160a01b0381163314610c935760405163334bd91960e11b815260040160405180910390fd5b610c9d8282612645565b505050565b610caa6123d4565b60055481908110610ccd5760405162461bcd60e51b815260040161094d906134f6565b600354610100900460ff1615610d175760405162461bcd60e51b815260206004820152600f60248201526e18db185a5b481a5cc81c185d5cd959608a1b604482015260640161094d565b600060058381548110610d2c57610d2c61351b565b60009182526020808320868452600682526040808520338652909252922060079091029091019150610d5d8461118c565b600081600201548260010154670de0b6b3a764000085600301548560000154610d86919061359c565b610d9091906135c9565b610d9a9190613573565b610da49190613547565b90508015610dbd5760006002830155610dbd33826126c1565b60038301548254670de0b6b3a764000091610dd79161359c565b610de191906135c9565b6001830155604051818152859033907f34fcbac0073d7c3d388e51312faf357774904998eeb8fca628b9e6f65ee1cbf7906020015b60405180910390a35050505050565b60055460009083908110610e4b5760405162461bcd60e51b815260040161094d906134f6565b610e56848443610e5e565b949350505050565b60055460009084908110610e845760405162461bcd60e51b815260040161094d906134f6565b600060058681548110610e9957610e9961351b565b600091825260208083208984526006825260408085206001600160a01b038b1686529092529220600360079092029092019081015460048201546002830154929450909187118015610eea57508015155b15610f4e576000610eff8560020154896114e0565b90506000600454866001015483610f16919061359c565b610f2091906135c9565b905082610f3582670de0b6b3a764000061359c565b610f3f91906135c9565b610f499085613547565b935050505b600283015460018401548454670de0b6b3a764000090610f6f90869061359c565b610f7991906135c9565b610f839190613573565b610f8d9190613547565b9998505050505050505050565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a008054600160401b810460ff16159067ffffffffffffffff16600081158015610fe05750825b905060008267ffffffffffffffff166001148015610ffd5750303b155b90508115801561100b575080155b156110295760405163f92ee8a960e01b815260040160405180910390fd5b845467ffffffffffffffff19166001178555831561105357845460ff60401b1916600160401b1785555b8688111580156110635750600086115b6110a45760405162461bcd60e51b8152602060048201526012602482015271696e76616c696420706172616d657465727360701b604482015260640161094d565b6110ac6127fd565b6110b46127fd565b6110bf6000336125a0565b506110ea7fcab03bc4dbcc648cd59d6bbe9f848d1e9092f914016aa290ee92e18700d1e6f9336125a0565b50611103600080516020613727833981519152336125a0565b5061110d89612015565b600088905560018790556002869055831561116257845460ff60401b19168555604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d29060200160405180910390a15b505050505050505050565b611175612805565b61117e826128aa565b61118882826128d4565b5050565b600554819081106111af5760405162461bcd60e51b815260040161094d906134f6565b6000600583815481106111c4576111c461351b565b90600052602060002090600702019050806002015443116111e457505050565b60008061120383600101546111fd8560020154436114e0565b90612991565b91509150816112245760405162461bcd60e51b815260040161094d906135eb565b6004546112329082906129dc565b9092509050816112545760405162461bcd60e51b815260040161094d906135eb565b600483015480156113055760008061127484670de0b6b3a7640000612991565b91509150816112955760405162461bcd60e51b815260040161094d906135eb565b61129f81846129dc565b9092509050816112c15760405162461bcd60e51b815260040161094d906135eb565b6000806112db838960030154612a0f90919063ffffffff16565b91509150816112fc5760405162461bcd60e51b815260040161094d906135eb565b60038801555050505b436002850181905560405183815287907ff5d2d72d9b25d6853afd7d0554a113b705234b6a68bb36b7f143662994632411906020015b60405180910390a3505050505050565b6000611355612a2a565b5060008051602061374783398151915290565b60008051602061372783398151915261138081612593565b60035460ff166113dd5760405162461bcd60e51b815260206004820152602260248201527f776974686472617720686173206265656e20616c726561647920756e70617573604482015261195960f21b606482015260840161094d565b6003805460ff191690556040517f1c84bcaead48b692cc46b9b12e9a068951a59c99a2e2bf10b00b60b403cf12e290600090a150565b60008051602061372783398151915261142b81612593565b60035460ff161561147e5760405162461bcd60e51b815260206004820181905260248201527f776974686472617720686173206265656e20616c726561647920706175736564604482015260640161094d565b6003805460ff191660011790556040517f8099f593a6aaecd68b6494933cd71f703376ac3975be83692e1b7d800abf683790600090a150565b60055460005b81811015611188576114ce8161118c565b806114d88161355a565b9150506114bd565b6000818311156115225760405162461bcd60e51b815260206004820152600d60248201526c696e76616c696420626c6f636b60981b604482015260640161094d565b6000548310156115325760005492505b6001548211156115425760015491505b818311156115a55760405162461bcd60e51b815260206004820152602a60248201527f656e6420626c6f636b206d7573742062652067726561746572207468616e20736044820152697461727420626c6f636b60b01b606482015260840161094d565b60006115b960025485856111fd9190613573565b925090508061097c5760405162461bcd60e51b81526020600482015260136024820152726d756c7469706c696572206f766572666c6f7760681b604482015260640161094d565b60008051602061372783398151915261161881612593565b600354610100900460ff16156116705760405162461bcd60e51b815260206004820152601d60248201527f636c61696d20686173206265656e20616c726561647920706175736564000000604482015260640161094d565b6003805461ff0019166101001790556040517f6d73d6b34c378ab3bf6630206d60b7882801b91d03ee20d016ff0d5054db81e190600090a150565b6000918252600080516020613767833981519152602090815260408084206001600160a01b0393909316845291905290205460ff1690565b6116eb6123d4565b6005548290811061170e5760405162461bcd60e51b815260040161094d906134f6565b60035460ff16156117565760405162461bcd60e51b81526020600482015260126024820152711dda5d1a191c985dc81a5cc81c185d5cd95960721b604482015260640161094d565b60006005848154811061176b5761176b61351b565b6000918252602080832087845260068252604080852033865290925292208054600790920290920192508411156117e45760405162461bcd60e51b815260206004820181905260248201527f4e6f7420656e6f756768207374616b696e6720746f6b656e2062616c616e6365604482015260640161094d565b6117ed8561118c565b60008160010154670de0b6b3a764000084600301548460000154611811919061359c565b61181b91906135c9565b6118259190613573565b905080156118435780826002015461183d9190613547565b60028301555b84156118a9578154611856908690613573565b8255604080518082019091528581526006840154600384019190602082019061187f9043613547565b90528154600181810184556000938452602093849020835160029093020191825592909101519101555b8483600401546118b99190613573565b600484015560038301548254670de0b6b3a7640000916118d89161359c565b6118e291906135c9565b6001830155604051858152869033907fc80277265097707f6f12a4ac4c09d46c9926e2eea2536f63616cb04d9fcad7d69060200161133b565b60008051602061372783398151915261193381612593565b60055415611966576001600160a01b0386166119615760405162461bcd60e51b815260040161094d9061360d565b61198d565b6001600160a01b0386161561198d5760405162461bcd60e51b815260040161094d9061360d565b600083116119dd5760405162461bcd60e51b815260206004820152601e60248201527f696e76616c6964207769746864726177206c6f636b656420626c6f636b730000604482015260640161094d565b6001544310611a1e5760405162461bcd60e51b815260206004820152600d60248201526c105b1c9958591e48195b991959609a1b604482015260640161094d565b8115611a2c57611a2c6114b7565b600080544311611a3e57600054611a40565b435b905085600454611a509190613547565b6004556040805160e0810182526001600160a01b0389811680835260208084018b81528486018781526000606087018181526080880182815260a089018f815260c08a018f815260058054600181018255955299517f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db0600790950294850180546001600160a01b03191691909a161790985593517f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db183015591517f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db282015590517f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db382015590517f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db482015592517f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db584015592517f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db6909201919091558251888152918201879052839289927f0fa296fce13e7a0e622b3a892e66220c248337289483a3cfa4130cde0caa1346910160405180910390a450505050505050565b600080516020613727833981519152611c2581612593565b60008211611c695760405162461bcd60e51b815260206004820152601160248201527034b73b30b634b2103830b930b6b2ba32b960791b604482015260640161094d565b600282905560405182907f4c70925b625536dd633f6bd2d615c67fddc2e7c63c31164047a981a0df3fee5490600090a25050565b600080516020613727833981519152611cb581612593565b816000541115611cd75760405162461bcd60e51b815260040161094d90613644565b600182905560405182907f1132c5baccb51da3d049fabc819697dc845fa224ad59d9b555507d6446b4085090600090a25050565b611d1482610983565b611d1d81612593565b610c648383612645565b600080516020613727833981519152611d3f81612593565b60055484908110611d625760405162461bcd60e51b815260040161094d906134f6565b8360058681548110611d7657611d7661351b565b9060005260206000209060070201600501819055508260058681548110611d9f57611d9f61351b565b9060005260206000209060070201600601819055508284867f30dffdedaa3e3b4849298233f7cd71d229956e875ab09270498c96b7cf9181fd60405160405180910390a45050505050565b600080516020613727833981519152611e0281612593565b600354610100900460ff16611e595760405162461bcd60e51b815260206004820152601f60248201527f636c61696d20686173206265656e20616c726561647920756e70617573656400604482015260640161094d565b6003805461ff00191690556040517fe72cb12952f056e3e7496019725f20a13108ca420f67f1ee9c9cdab73fb8ce8590600090a150565b611e986123d4565b60055482908110611ebb5760405162461bcd60e51b815260040161094d906134f6565b82600003611f0b5760405162461bcd60e51b815260206004820152601f60248201527f6465706f736974206e6f7420737570706f727420455448207374616b696e6700604482015260640161094d565b600060058481548110611f2057611f2061351b565b9060005260206000209060070201905080600501548311611f835760405162461bcd60e51b815260206004820152601b60248201527f6465706f73697420616d6f756e7420697320746f6f20736d616c6c0000000000604482015260640161094d565b8215611fa0578054611fa0906001600160a01b0316333086612a73565b610c648484612aac565b600080516020613727833981519152611fc281612593565b600154821115611fe45760405162461bcd60e51b815260040161094d90613644565b600082815560405183917f63b90b79f11a0f132bcb2c4a4ddd44abda45c1308a83b2919318df7f5f8b7be491a25050565b60008051602061372783398151915261202d81612593565b6003805462010000600160b01b031916620100006001600160a01b0385811682029290921792839055604051920416907f153aae53b92218044bd5f43922617c6b253e50ac98a41b44c3acb5625ded348890600090a25050565b61208f6123d4565b600060056000815481106120a5576120a561351b565b6000918252602090912060079091020180549091506001600160a01b0316156120e05760405162461bcd60e51b815260040161094d9061360d565b600581015434908110156121365760405162461bcd60e51b815260206004820152601b60248201527f6465706f73697420616d6f756e7420697320746f6f20736d616c6c0000000000604482015260640161094d565b611188600082612aac565b60008051602061372783398151915261215981612593565b6005548490811061217c5760405162461bcd60e51b815260040161094d906134f6565b600084116121c25760405162461bcd60e51b81526020600482015260136024820152721a5b9d985b1a59081c1bdbdb081dd95a59da1d606a1b604482015260640161094d565b82156121d0576121d06114b7565b83600586815481106121e4576121e461351b565b9060005260206000209060070201600101546004546122039190613573565b61220d9190613547565b60048190555083600586815481106122275761222761351b565b90600052602060002090600702016001018190555083857f4b8fa3d6a87cb21d1bf4978bf60628ae358a28ac7f39de1751a481c6dd957617600454604051610e1691815260200190565b6005818154811061228157600080fd5b600091825260209091206007909102018054600182015460028301546003840154600485015460058601546006909601546001600160a01b039095169650929491939092919087565b6000808360058054905081106122f25760405162461bcd60e51b815260040161094d906134f6565b60008581526006602090815260408083206001600160a01b03881684529091528120905b60038201548110156123ca57438260030182815481106123385761233861351b565b90600052602060002090600202016001015411612384578160030181815481106123645761236461351b565b906000526020600020906002020160000154846123819190613547565b93505b8160030181815481106123995761239961351b565b906000526020600020906002020160000154856123b69190613547565b9450806123c28161355a565b915050612316565b5050509250929050565b7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033005460ff16156124175760405163d93c066560e01b815260040160405180910390fd5b565b600080836001600160a01b03168360405160006040518083038185875af1925050503d8060008114612467576040519150601f19603f3d011682016040523d82523d6000602084013e61246c565b606091505b5091509150816124be5760405162461bcd60e51b815260206004820152601860248201527f455448207472616e736665722063616c6c206661696c65640000000000000000604482015260640161094d565b805115610c6457808060200190518101906124d9919061368e565b610c645760405162461bcd60e51b815260206004820152602660248201527f455448207472616e73666572206f7065726174696f6e20646964206e6f7420736044820152651d58d8d9595960d21b606482015260840161094d565b6040516001600160a01b03838116602483015260448201839052610c9d91859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050612e34565b61259d8133612e97565b50565b60006000805160206137678339815191526125bb84846116ab565b61263b576000848152602082815260408083206001600160a01b03871684529091529020805460ff191660011790556125f13390565b6001600160a01b0316836001600160a01b0316857f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a46001915050610921565b6000915050610921565b600060008051602061376783398151915261266084846116ab565b1561263b576000848152602082815260408083206001600160a01b0387168085529252808320805460ff1916905551339287917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a46001915050610921565b6003546040516370a0823160e01b81523060048201526000916201000090046001600160a01b0316906370a0823190602401602060405180830381865afa158015612710573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061273491906136ab565b9050808211156127bd5760035460405163a9059cbb60e01b81526001600160a01b03858116600483015260248201849052620100009092049091169063a9059cbb906044015b6020604051808303816000875af1158015612799573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c64919061368e565b60035460405163a9059cbb60e01b81526001600160a01b03858116600483015260248201859052620100009092049091169063a9059cbb9060440161277a565b612417612ed0565b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016148061288c57507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316612880600080516020613747833981519152546001600160a01b031690565b6001600160a01b031614155b156124175760405163703e46dd60e11b815260040160405180910390fd5b7fcab03bc4dbcc648cd59d6bbe9f848d1e9092f914016aa290ee92e18700d1e6f961118881612593565b816001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa92505050801561292e575060408051601f3d908101601f1916820190925261292b918101906136ab565b60015b61295657604051634c9c8ce360e01b81526001600160a01b038316600482015260240161094d565b600080516020613747833981519152811461298757604051632a87526960e21b81526004810182905260240161094d565b610c9d8383612f19565b600080836000036129a857506001905060006129d5565b838302838582816129bb576129bb6135b3565b04146129ce5760008092509250506129d5565b6001925090505b9250929050565b600080826000036129f2575060009050806129d5565b6001838581612a0357612a036135b3565b04915091509250929050565b600080838301848110156129ce5760008092509250506129d5565b306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146124175760405163703e46dd60e11b815260040160405180910390fd5b6040516001600160a01b038481166024830152838116604483015260648201839052610c649186918216906323b872dd90608401612561565b600060058381548110612ac157612ac161351b565b60009182526020808320868452600682526040808520338652909252922060079091029091019150612af28461118c565b805415612c7b57600382015481546000918291612b0e91612991565b9150915081612b2f5760405162461bcd60e51b815260040161094d906136c4565b612b4181670de0b6b3a76400006129dc565b909250905081612b935760405162461bcd60e51b815260206004820152601a60248201527f6163635354206469762031206574686572206f766572666c6f77000000000000604482015260640161094d565b600080612bad856001015484612f6f90919063ffffffff16565b9150915081612bfe5760405162461bcd60e51b815260206004820152601e60248201527f6163635354207375622066696e6973686564524343206f766572666c6f770000604482015260640161094d565b8015612c7657600080612c1e838860020154612a0f90919063ffffffff16565b9150915081612c6f5760405162461bcd60e51b815260206004820152601860248201527f757365722070656e64696e67524343206f766572666c6f770000000000000000604482015260640161094d565b6002870155505b505050505b8215612ce05780546000908190612c929086612a0f565b9150915081612cdc5760405162461bcd60e51b815260206004820152601660248201527575736572207374416d6f756e74206f766572666c6f7760501b604482015260640161094d565b8255505b600080612cfa858560040154612a0f90919063ffffffff16565b9150915081612d4b5760405162461bcd60e51b815260206004820152601b60248201527f706f6f6c207374546f6b656e416d6f756e74206f766572666c6f770000000000604482015260640161094d565b60048401819055600384015483546000918291612d6791612991565b9150915081612d885760405162461bcd60e51b815260040161094d906136c4565b612d9a81670de0b6b3a76400006129dc565b909250905081612dec5760405162461bcd60e51b815260206004820181905260248201527f66696e6973686564524343206469762031206574686572206f766572666c6f77604482015260640161094d565b60018501819055604051878152889033907f90890809c654f11d6e72a28fa60149770a0d11ec6c92319d6ceb2bb0a4ea1a159060200160405180910390a35050505050505050565b6000612e496001600160a01b03841683612f91565b90508051600014158015612e6e575080806020019051810190612e6c919061368e565b155b15610c9d57604051635274afe760e01b81526001600160a01b038416600482015260240161094d565b612ea182826116ab565b6111885760405163e2517d3f60e01b81526001600160a01b03821660048201526024810183905260440161094d565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054600160401b900460ff1661241757604051631afcd79f60e31b815260040160405180910390fd5b612f2282612fa6565b6040516001600160a01b038316907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a2805115612f6757610c9d828261300b565b611188613081565b60008083831115612f85575060009050806129d5565b50600193919092039150565b6060612f9f838360006130a0565b9392505050565b806001600160a01b03163b600003612fdc57604051634c9c8ce360e01b81526001600160a01b038216600482015260240161094d565b60008051602061374783398151915280546001600160a01b0319166001600160a01b0392909216919091179055565b6060600080846001600160a01b031684604051613028919061370a565b600060405180830381855af49150503d8060008114613063576040519150601f19603f3d011682016040523d82523d6000602084013e613068565b606091505b509150915061307885838361313d565b95945050505050565b34156124175760405163b398979f60e01b815260040160405180910390fd5b6060814710156130c55760405163cd78605960e01b815230600482015260240161094d565b600080856001600160a01b031684866040516130e1919061370a565b60006040518083038185875af1925050503d806000811461311e576040519150601f19603f3d011682016040523d82523d6000602084013e613123565b606091505b509150915061313386838361313d565b9695505050505050565b6060826131525761314d82613199565b612f9f565b815115801561316957506001600160a01b0384163b155b1561319257604051639996b31560e01b81526001600160a01b038516600482015260240161094d565b5080612f9f565b8051156131a95780518082602001fd5b604051630a12f52160e11b815260040160405180910390fd5b6000602082840312156131d457600080fd5b81356001600160e01b031981168114612f9f57600080fd5b6001600160a01b038116811461259d57600080fd5b6000806040838503121561321457600080fd5b823591506020830135613226816131ec565b809150509250929050565b60006020828403121561324357600080fd5b5035919050565b60008060006060848603121561325f57600080fd5b833592506020840135613271816131ec565b929592945050506040919091013590565b6000806000806080858703121561329857600080fd5b84356132a3816131ec565b966020860135965060408601359560600135945092505050565b634e487b7160e01b600052604160045260246000fd5b600080604083850312156132e657600080fd5b82356132f1816131ec565b9150602083013567ffffffffffffffff8082111561330e57600080fd5b818501915085601f83011261332257600080fd5b813581811115613334576133346132bd565b604051601f8201601f19908116603f0116810190838211818310171561335c5761335c6132bd565b8160405282815288602084870101111561337557600080fd5b8260208601602083013760006020848301015280955050505050509250929050565b600080604083850312156133aa57600080fd5b50508035926020909101359150565b60005b838110156133d45781810151838201526020016133bc565b50506000910152565b60208152600082518060208401526133fc8160408501602087016133b9565b601f01601f19169190910160400192915050565b801515811461259d57600080fd5b600080600080600060a0868803121561343657600080fd5b8535613441816131ec565b9450602086013593506040860135925060608601359150608086013561346681613410565b809150509295509295909350565b60008060006060848603121561348957600080fd5b505081359360208301359350604090920135919050565b6000602082840312156134b257600080fd5b8135612f9f816131ec565b6000806000606084860312156134d257600080fd5b833592506020840135915060408401356134eb81613410565b809150509250925092565b6020808252600b908201526a1a5b9d985b1a59081c1a5960aa1b604082015260600190565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8082018082111561092157610921613531565b60006001820161356c5761356c613531565b5060010190565b8181038181111561092157610921613531565b634e487b7160e01b600052603160045260246000fd5b808202811582820484141761092157610921613531565b634e487b7160e01b600052601260045260246000fd5b6000826135e657634e487b7160e01b600052601260045260246000fd5b500490565b6020808252600890820152676f766572666c6f7760c01b604082015260600190565b6020808252601d908201527f696e76616c6964207374616b696e6720746f6b656e2061646472657373000000604082015260600190565b6020808252602a908201527f737461727420626c6f636b206d75737420626520736d616c6c6572207468616e60408201526920656e6420626c6f636b60b01b606082015260800190565b6000602082840312156136a057600080fd5b8151612f9f81613410565b6000602082840312156136bd57600080fd5b5051919050565b60208082526026908201527f75736572207374416d6f756e74206d756c206163635243435065725354206f766040820152656572666c6f7760d01b606082015260800190565b6000825161371c8184602087016133b9565b919091019291505056fe589d473ba17c0f47d494622893831497bad25919b9afb8e33e9521b8963fccde360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800a2646970667358221220a742b5e02f0474fd10ca537b545a317b28a05025fe2f81f888f7257c460cc4a464736f6c63430008140033",
}

// RCCStakeABI is the input ABI used to generate the binding from.
// Deprecated: Use RCCStakeMetaData.ABI instead.
var RCCStakeABI = RCCStakeMetaData.ABI

// RCCStakeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use RCCStakeMetaData.Bin instead.
var RCCStakeBin = RCCStakeMetaData.Bin

// DeployRCCStake deploys a new Ethereum contract, binding an instance of RCCStake to it.
func DeployRCCStake(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RCCStake, error) {
	parsed, err := RCCStakeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(RCCStakeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RCCStake{RCCStakeCaller: RCCStakeCaller{contract: contract}, RCCStakeTransactor: RCCStakeTransactor{contract: contract}, RCCStakeFilterer: RCCStakeFilterer{contract: contract}}, nil
}

// RCCStake is an auto generated Go binding around an Ethereum contract.
type RCCStake struct {
	RCCStakeCaller     // Read-only binding to the contract
	RCCStakeTransactor // Write-only binding to the contract
	RCCStakeFilterer   // Log filterer for contract events
}

// RCCStakeCaller is an auto generated read-only Go binding around an Ethereum contract.
type RCCStakeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RCCStakeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RCCStakeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RCCStakeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RCCStakeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RCCStakeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RCCStakeSession struct {
	Contract     *RCCStake         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RCCStakeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RCCStakeCallerSession struct {
	Contract *RCCStakeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// RCCStakeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RCCStakeTransactorSession struct {
	Contract     *RCCStakeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// RCCStakeRaw is an auto generated low-level Go binding around an Ethereum contract.
type RCCStakeRaw struct {
	Contract *RCCStake // Generic contract binding to access the raw methods on
}

// RCCStakeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RCCStakeCallerRaw struct {
	Contract *RCCStakeCaller // Generic read-only contract binding to access the raw methods on
}

// RCCStakeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RCCStakeTransactorRaw struct {
	Contract *RCCStakeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRCCStake creates a new instance of RCCStake, bound to a specific deployed contract.
func NewRCCStake(address common.Address, backend bind.ContractBackend) (*RCCStake, error) {
	contract, err := bindRCCStake(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RCCStake{RCCStakeCaller: RCCStakeCaller{contract: contract}, RCCStakeTransactor: RCCStakeTransactor{contract: contract}, RCCStakeFilterer: RCCStakeFilterer{contract: contract}}, nil
}

// NewRCCStakeCaller creates a new read-only instance of RCCStake, bound to a specific deployed contract.
func NewRCCStakeCaller(address common.Address, caller bind.ContractCaller) (*RCCStakeCaller, error) {
	contract, err := bindRCCStake(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RCCStakeCaller{contract: contract}, nil
}

// NewRCCStakeTransactor creates a new write-only instance of RCCStake, bound to a specific deployed contract.
func NewRCCStakeTransactor(address common.Address, transactor bind.ContractTransactor) (*RCCStakeTransactor, error) {
	contract, err := bindRCCStake(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RCCStakeTransactor{contract: contract}, nil
}

// NewRCCStakeFilterer creates a new log filterer instance of RCCStake, bound to a specific deployed contract.
func NewRCCStakeFilterer(address common.Address, filterer bind.ContractFilterer) (*RCCStakeFilterer, error) {
	contract, err := bindRCCStake(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RCCStakeFilterer{contract: contract}, nil
}

// bindRCCStake binds a generic wrapper to an already deployed contract.
func bindRCCStake(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := RCCStakeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RCCStake *RCCStakeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _RCCStake.Contract.RCCStakeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RCCStake *RCCStakeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RCCStake.Contract.RCCStakeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RCCStake *RCCStakeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RCCStake.Contract.RCCStakeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RCCStake *RCCStakeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _RCCStake.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RCCStake *RCCStakeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RCCStake.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RCCStake *RCCStakeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RCCStake.Contract.contract.Transact(opts, method, params...)
}

// ADMINROLE is a free data retrieval call binding the contract method 0x75b238fc.
//
// Solidity: function ADMIN_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeCaller) ADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ADMINROLE is a free data retrieval call binding the contract method 0x75b238fc.
//
// Solidity: function ADMIN_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeSession) ADMINROLE() ([32]byte, error) {
	return _RCCStake.Contract.ADMINROLE(&_RCCStake.CallOpts)
}

// ADMINROLE is a free data retrieval call binding the contract method 0x75b238fc.
//
// Solidity: function ADMIN_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeCallerSession) ADMINROLE() ([32]byte, error) {
	return _RCCStake.Contract.ADMINROLE(&_RCCStake.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _RCCStake.Contract.DEFAULTADMINROLE(&_RCCStake.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _RCCStake.Contract.DEFAULTADMINROLE(&_RCCStake.CallOpts)
}

// ETHPID is a free data retrieval call binding the contract method 0xbfc3ebba.
//
// Solidity: function ETH_PID() view returns(uint256)
func (_RCCStake *RCCStakeCaller) ETHPID(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "ETH_PID")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ETHPID is a free data retrieval call binding the contract method 0xbfc3ebba.
//
// Solidity: function ETH_PID() view returns(uint256)
func (_RCCStake *RCCStakeSession) ETHPID() (*big.Int, error) {
	return _RCCStake.Contract.ETHPID(&_RCCStake.CallOpts)
}

// ETHPID is a free data retrieval call binding the contract method 0xbfc3ebba.
//
// Solidity: function ETH_PID() view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) ETHPID() (*big.Int, error) {
	return _RCCStake.Contract.ETHPID(&_RCCStake.CallOpts)
}

// RCC is a free data retrieval call binding the contract method 0xa72d5bf4.
//
// Solidity: function RCC() view returns(address)
func (_RCCStake *RCCStakeCaller) RCC(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "RCC")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// RCC is a free data retrieval call binding the contract method 0xa72d5bf4.
//
// Solidity: function RCC() view returns(address)
func (_RCCStake *RCCStakeSession) RCC() (common.Address, error) {
	return _RCCStake.Contract.RCC(&_RCCStake.CallOpts)
}

// RCC is a free data retrieval call binding the contract method 0xa72d5bf4.
//
// Solidity: function RCC() view returns(address)
func (_RCCStake *RCCStakeCallerSession) RCC() (common.Address, error) {
	return _RCCStake.Contract.RCC(&_RCCStake.CallOpts)
}

// UPGRADEINTERFACEVERSION is a free data retrieval call binding the contract method 0xad3cb1cc.
//
// Solidity: function UPGRADE_INTERFACE_VERSION() view returns(string)
func (_RCCStake *RCCStakeCaller) UPGRADEINTERFACEVERSION(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "UPGRADE_INTERFACE_VERSION")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// UPGRADEINTERFACEVERSION is a free data retrieval call binding the contract method 0xad3cb1cc.
//
// Solidity: function UPGRADE_INTERFACE_VERSION() view returns(string)
func (_RCCStake *RCCStakeSession) UPGRADEINTERFACEVERSION() (string, error) {
	return _RCCStake.Contract.UPGRADEINTERFACEVERSION(&_RCCStake.CallOpts)
}

// UPGRADEINTERFACEVERSION is a free data retrieval call binding the contract method 0xad3cb1cc.
//
// Solidity: function UPGRADE_INTERFACE_VERSION() view returns(string)
func (_RCCStake *RCCStakeCallerSession) UPGRADEINTERFACEVERSION() (string, error) {
	return _RCCStake.Contract.UPGRADEINTERFACEVERSION(&_RCCStake.CallOpts)
}

// UPGRADEROLE is a free data retrieval call binding the contract method 0xb908afa8.
//
// Solidity: function UPGRADE_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeCaller) UPGRADEROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "UPGRADE_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// UPGRADEROLE is a free data retrieval call binding the contract method 0xb908afa8.
//
// Solidity: function UPGRADE_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeSession) UPGRADEROLE() ([32]byte, error) {
	return _RCCStake.Contract.UPGRADEROLE(&_RCCStake.CallOpts)
}

// UPGRADEROLE is a free data retrieval call binding the contract method 0xb908afa8.
//
// Solidity: function UPGRADE_ROLE() view returns(bytes32)
func (_RCCStake *RCCStakeCallerSession) UPGRADEROLE() ([32]byte, error) {
	return _RCCStake.Contract.UPGRADEROLE(&_RCCStake.CallOpts)
}

// ClaimPaused is a free data retrieval call binding the contract method 0xab5e124a.
//
// Solidity: function claimPaused() view returns(bool)
func (_RCCStake *RCCStakeCaller) ClaimPaused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "claimPaused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// ClaimPaused is a free data retrieval call binding the contract method 0xab5e124a.
//
// Solidity: function claimPaused() view returns(bool)
func (_RCCStake *RCCStakeSession) ClaimPaused() (bool, error) {
	return _RCCStake.Contract.ClaimPaused(&_RCCStake.CallOpts)
}

// ClaimPaused is a free data retrieval call binding the contract method 0xab5e124a.
//
// Solidity: function claimPaused() view returns(bool)
func (_RCCStake *RCCStakeCallerSession) ClaimPaused() (bool, error) {
	return _RCCStake.Contract.ClaimPaused(&_RCCStake.CallOpts)
}

// EndBlock is a free data retrieval call binding the contract method 0x083c6323.
//
// Solidity: function endBlock() view returns(uint256)
func (_RCCStake *RCCStakeCaller) EndBlock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "endBlock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EndBlock is a free data retrieval call binding the contract method 0x083c6323.
//
// Solidity: function endBlock() view returns(uint256)
func (_RCCStake *RCCStakeSession) EndBlock() (*big.Int, error) {
	return _RCCStake.Contract.EndBlock(&_RCCStake.CallOpts)
}

// EndBlock is a free data retrieval call binding the contract method 0x083c6323.
//
// Solidity: function endBlock() view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) EndBlock() (*big.Int, error) {
	return _RCCStake.Contract.EndBlock(&_RCCStake.CallOpts)
}

// GetMultiplier is a free data retrieval call binding the contract method 0x8dbb1e3a.
//
// Solidity: function getMultiplier(uint256 _from, uint256 _to) view returns(uint256 multiplier)
func (_RCCStake *RCCStakeCaller) GetMultiplier(opts *bind.CallOpts, _from *big.Int, _to *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "getMultiplier", _from, _to)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetMultiplier is a free data retrieval call binding the contract method 0x8dbb1e3a.
//
// Solidity: function getMultiplier(uint256 _from, uint256 _to) view returns(uint256 multiplier)
func (_RCCStake *RCCStakeSession) GetMultiplier(_from *big.Int, _to *big.Int) (*big.Int, error) {
	return _RCCStake.Contract.GetMultiplier(&_RCCStake.CallOpts, _from, _to)
}

// GetMultiplier is a free data retrieval call binding the contract method 0x8dbb1e3a.
//
// Solidity: function getMultiplier(uint256 _from, uint256 _to) view returns(uint256 multiplier)
func (_RCCStake *RCCStakeCallerSession) GetMultiplier(_from *big.Int, _to *big.Int) (*big.Int, error) {
	return _RCCStake.Contract.GetMultiplier(&_RCCStake.CallOpts, _from, _to)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_RCCStake *RCCStakeCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_RCCStake *RCCStakeSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _RCCStake.Contract.GetRoleAdmin(&_RCCStake.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_RCCStake *RCCStakeCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _RCCStake.Contract.GetRoleAdmin(&_RCCStake.CallOpts, role)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_RCCStake *RCCStakeCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_RCCStake *RCCStakeSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _RCCStake.Contract.HasRole(&_RCCStake.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_RCCStake *RCCStakeCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _RCCStake.Contract.HasRole(&_RCCStake.CallOpts, role, account)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_RCCStake *RCCStakeCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_RCCStake *RCCStakeSession) Paused() (bool, error) {
	return _RCCStake.Contract.Paused(&_RCCStake.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_RCCStake *RCCStakeCallerSession) Paused() (bool, error) {
	return _RCCStake.Contract.Paused(&_RCCStake.CallOpts)
}

// PendingRCC is a free data retrieval call binding the contract method 0x3b82783e.
//
// Solidity: function pendingRCC(uint256 _pid, address _user) view returns(uint256)
func (_RCCStake *RCCStakeCaller) PendingRCC(opts *bind.CallOpts, _pid *big.Int, _user common.Address) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "pendingRCC", _pid, _user)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// PendingRCC is a free data retrieval call binding the contract method 0x3b82783e.
//
// Solidity: function pendingRCC(uint256 _pid, address _user) view returns(uint256)
func (_RCCStake *RCCStakeSession) PendingRCC(_pid *big.Int, _user common.Address) (*big.Int, error) {
	return _RCCStake.Contract.PendingRCC(&_RCCStake.CallOpts, _pid, _user)
}

// PendingRCC is a free data retrieval call binding the contract method 0x3b82783e.
//
// Solidity: function pendingRCC(uint256 _pid, address _user) view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) PendingRCC(_pid *big.Int, _user common.Address) (*big.Int, error) {
	return _RCCStake.Contract.PendingRCC(&_RCCStake.CallOpts, _pid, _user)
}

// PendingRCCByBlockNumber is a free data retrieval call binding the contract method 0x41721ab7.
//
// Solidity: function pendingRCCByBlockNumber(uint256 _pid, address _user, uint256 _blockNumber) view returns(uint256)
func (_RCCStake *RCCStakeCaller) PendingRCCByBlockNumber(opts *bind.CallOpts, _pid *big.Int, _user common.Address, _blockNumber *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "pendingRCCByBlockNumber", _pid, _user, _blockNumber)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// PendingRCCByBlockNumber is a free data retrieval call binding the contract method 0x41721ab7.
//
// Solidity: function pendingRCCByBlockNumber(uint256 _pid, address _user, uint256 _blockNumber) view returns(uint256)
func (_RCCStake *RCCStakeSession) PendingRCCByBlockNumber(_pid *big.Int, _user common.Address, _blockNumber *big.Int) (*big.Int, error) {
	return _RCCStake.Contract.PendingRCCByBlockNumber(&_RCCStake.CallOpts, _pid, _user, _blockNumber)
}

// PendingRCCByBlockNumber is a free data retrieval call binding the contract method 0x41721ab7.
//
// Solidity: function pendingRCCByBlockNumber(uint256 _pid, address _user, uint256 _blockNumber) view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) PendingRCCByBlockNumber(_pid *big.Int, _user common.Address, _blockNumber *big.Int) (*big.Int, error) {
	return _RCCStake.Contract.PendingRCCByBlockNumber(&_RCCStake.CallOpts, _pid, _user, _blockNumber)
}

// Pool is a free data retrieval call binding the contract method 0xfe313112.
//
// Solidity: function pool(uint256 ) view returns(address stTokenAddress, uint256 poolWeight, uint256 lastRewardBlock, uint256 accRCCPerST, uint256 stTokenAmount, uint256 minDepositAmount, uint256 unstakeLockedBlocks)
func (_RCCStake *RCCStakeCaller) Pool(opts *bind.CallOpts, arg0 *big.Int) (struct {
	StTokenAddress      common.Address
	PoolWeight          *big.Int
	LastRewardBlock     *big.Int
	AccRCCPerST         *big.Int
	StTokenAmount       *big.Int
	MinDepositAmount    *big.Int
	UnstakeLockedBlocks *big.Int
}, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "pool", arg0)

	outstruct := new(struct {
		StTokenAddress      common.Address
		PoolWeight          *big.Int
		LastRewardBlock     *big.Int
		AccRCCPerST         *big.Int
		StTokenAmount       *big.Int
		MinDepositAmount    *big.Int
		UnstakeLockedBlocks *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.StTokenAddress = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.PoolWeight = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.LastRewardBlock = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.AccRCCPerST = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.StTokenAmount = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)
	outstruct.MinDepositAmount = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)
	outstruct.UnstakeLockedBlocks = *abi.ConvertType(out[6], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// Pool is a free data retrieval call binding the contract method 0xfe313112.
//
// Solidity: function pool(uint256 ) view returns(address stTokenAddress, uint256 poolWeight, uint256 lastRewardBlock, uint256 accRCCPerST, uint256 stTokenAmount, uint256 minDepositAmount, uint256 unstakeLockedBlocks)
func (_RCCStake *RCCStakeSession) Pool(arg0 *big.Int) (struct {
	StTokenAddress      common.Address
	PoolWeight          *big.Int
	LastRewardBlock     *big.Int
	AccRCCPerST         *big.Int
	StTokenAmount       *big.Int
	MinDepositAmount    *big.Int
	UnstakeLockedBlocks *big.Int
}, error) {
	return _RCCStake.Contract.Pool(&_RCCStake.CallOpts, arg0)
}

// Pool is a free data retrieval call binding the contract method 0xfe313112.
//
// Solidity: function pool(uint256 ) view returns(address stTokenAddress, uint256 poolWeight, uint256 lastRewardBlock, uint256 accRCCPerST, uint256 stTokenAmount, uint256 minDepositAmount, uint256 unstakeLockedBlocks)
func (_RCCStake *RCCStakeCallerSession) Pool(arg0 *big.Int) (struct {
	StTokenAddress      common.Address
	PoolWeight          *big.Int
	LastRewardBlock     *big.Int
	AccRCCPerST         *big.Int
	StTokenAmount       *big.Int
	MinDepositAmount    *big.Int
	UnstakeLockedBlocks *big.Int
}, error) {
	return _RCCStake.Contract.Pool(&_RCCStake.CallOpts, arg0)
}

// PoolLength is a free data retrieval call binding the contract method 0x081e3eda.
//
// Solidity: function poolLength() view returns(uint256)
func (_RCCStake *RCCStakeCaller) PoolLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "poolLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// PoolLength is a free data retrieval call binding the contract method 0x081e3eda.
//
// Solidity: function poolLength() view returns(uint256)
func (_RCCStake *RCCStakeSession) PoolLength() (*big.Int, error) {
	return _RCCStake.Contract.PoolLength(&_RCCStake.CallOpts)
}

// PoolLength is a free data retrieval call binding the contract method 0x081e3eda.
//
// Solidity: function poolLength() view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) PoolLength() (*big.Int, error) {
	return _RCCStake.Contract.PoolLength(&_RCCStake.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_RCCStake *RCCStakeCaller) ProxiableUUID(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "proxiableUUID")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_RCCStake *RCCStakeSession) ProxiableUUID() ([32]byte, error) {
	return _RCCStake.Contract.ProxiableUUID(&_RCCStake.CallOpts)
}

// ProxiableUUID is a free data retrieval call binding the contract method 0x52d1902d.
//
// Solidity: function proxiableUUID() view returns(bytes32)
func (_RCCStake *RCCStakeCallerSession) ProxiableUUID() ([32]byte, error) {
	return _RCCStake.Contract.ProxiableUUID(&_RCCStake.CallOpts)
}

// RccPerBlock is a free data retrieval call binding the contract method 0x70ff0173.
//
// Solidity: function rccPerBlock() view returns(uint256)
func (_RCCStake *RCCStakeCaller) RccPerBlock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "rccPerBlock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// RccPerBlock is a free data retrieval call binding the contract method 0x70ff0173.
//
// Solidity: function rccPerBlock() view returns(uint256)
func (_RCCStake *RCCStakeSession) RccPerBlock() (*big.Int, error) {
	return _RCCStake.Contract.RccPerBlock(&_RCCStake.CallOpts)
}

// RccPerBlock is a free data retrieval call binding the contract method 0x70ff0173.
//
// Solidity: function rccPerBlock() view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) RccPerBlock() (*big.Int, error) {
	return _RCCStake.Contract.RccPerBlock(&_RCCStake.CallOpts)
}

// StakingBalance is a free data retrieval call binding the contract method 0x11548234.
//
// Solidity: function stakingBalance(uint256 _pid, address _user) view returns(uint256)
func (_RCCStake *RCCStakeCaller) StakingBalance(opts *bind.CallOpts, _pid *big.Int, _user common.Address) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "stakingBalance", _pid, _user)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// StakingBalance is a free data retrieval call binding the contract method 0x11548234.
//
// Solidity: function stakingBalance(uint256 _pid, address _user) view returns(uint256)
func (_RCCStake *RCCStakeSession) StakingBalance(_pid *big.Int, _user common.Address) (*big.Int, error) {
	return _RCCStake.Contract.StakingBalance(&_RCCStake.CallOpts, _pid, _user)
}

// StakingBalance is a free data retrieval call binding the contract method 0x11548234.
//
// Solidity: function stakingBalance(uint256 _pid, address _user) view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) StakingBalance(_pid *big.Int, _user common.Address) (*big.Int, error) {
	return _RCCStake.Contract.StakingBalance(&_RCCStake.CallOpts, _pid, _user)
}

// StartBlock is a free data retrieval call binding the contract method 0x48cd4cb1.
//
// Solidity: function startBlock() view returns(uint256)
func (_RCCStake *RCCStakeCaller) StartBlock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "startBlock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// StartBlock is a free data retrieval call binding the contract method 0x48cd4cb1.
//
// Solidity: function startBlock() view returns(uint256)
func (_RCCStake *RCCStakeSession) StartBlock() (*big.Int, error) {
	return _RCCStake.Contract.StartBlock(&_RCCStake.CallOpts)
}

// StartBlock is a free data retrieval call binding the contract method 0x48cd4cb1.
//
// Solidity: function startBlock() view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) StartBlock() (*big.Int, error) {
	return _RCCStake.Contract.StartBlock(&_RCCStake.CallOpts)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_RCCStake *RCCStakeCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_RCCStake *RCCStakeSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _RCCStake.Contract.SupportsInterface(&_RCCStake.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_RCCStake *RCCStakeCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _RCCStake.Contract.SupportsInterface(&_RCCStake.CallOpts, interfaceId)
}

// TotalPoolWeight is a free data retrieval call binding the contract method 0x02559004.
//
// Solidity: function totalPoolWeight() view returns(uint256)
func (_RCCStake *RCCStakeCaller) TotalPoolWeight(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "totalPoolWeight")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalPoolWeight is a free data retrieval call binding the contract method 0x02559004.
//
// Solidity: function totalPoolWeight() view returns(uint256)
func (_RCCStake *RCCStakeSession) TotalPoolWeight() (*big.Int, error) {
	return _RCCStake.Contract.TotalPoolWeight(&_RCCStake.CallOpts)
}

// TotalPoolWeight is a free data retrieval call binding the contract method 0x02559004.
//
// Solidity: function totalPoolWeight() view returns(uint256)
func (_RCCStake *RCCStakeCallerSession) TotalPoolWeight() (*big.Int, error) {
	return _RCCStake.Contract.TotalPoolWeight(&_RCCStake.CallOpts)
}

// User is a free data retrieval call binding the contract method 0x37849b3c.
//
// Solidity: function user(uint256 , address ) view returns(uint256 stAmount, uint256 finishedRCC, uint256 pendingRCC)
func (_RCCStake *RCCStakeCaller) User(opts *bind.CallOpts, arg0 *big.Int, arg1 common.Address) (struct {
	StAmount    *big.Int
	FinishedRCC *big.Int
	PendingRCC  *big.Int
}, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "user", arg0, arg1)

	outstruct := new(struct {
		StAmount    *big.Int
		FinishedRCC *big.Int
		PendingRCC  *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.StAmount = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.FinishedRCC = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.PendingRCC = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// User is a free data retrieval call binding the contract method 0x37849b3c.
//
// Solidity: function user(uint256 , address ) view returns(uint256 stAmount, uint256 finishedRCC, uint256 pendingRCC)
func (_RCCStake *RCCStakeSession) User(arg0 *big.Int, arg1 common.Address) (struct {
	StAmount    *big.Int
	FinishedRCC *big.Int
	PendingRCC  *big.Int
}, error) {
	return _RCCStake.Contract.User(&_RCCStake.CallOpts, arg0, arg1)
}

// User is a free data retrieval call binding the contract method 0x37849b3c.
//
// Solidity: function user(uint256 , address ) view returns(uint256 stAmount, uint256 finishedRCC, uint256 pendingRCC)
func (_RCCStake *RCCStakeCallerSession) User(arg0 *big.Int, arg1 common.Address) (struct {
	StAmount    *big.Int
	FinishedRCC *big.Int
	PendingRCC  *big.Int
}, error) {
	return _RCCStake.Contract.User(&_RCCStake.CallOpts, arg0, arg1)
}

// WithdrawAmount is a free data retrieval call binding the contract method 0xff423357.
//
// Solidity: function withdrawAmount(uint256 _pid, address _user) view returns(uint256 requestAmount, uint256 pendingWithdrawAmount)
func (_RCCStake *RCCStakeCaller) WithdrawAmount(opts *bind.CallOpts, _pid *big.Int, _user common.Address) (struct {
	RequestAmount         *big.Int
	PendingWithdrawAmount *big.Int
}, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "withdrawAmount", _pid, _user)

	outstruct := new(struct {
		RequestAmount         *big.Int
		PendingWithdrawAmount *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.RequestAmount = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.PendingWithdrawAmount = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// WithdrawAmount is a free data retrieval call binding the contract method 0xff423357.
//
// Solidity: function withdrawAmount(uint256 _pid, address _user) view returns(uint256 requestAmount, uint256 pendingWithdrawAmount)
func (_RCCStake *RCCStakeSession) WithdrawAmount(_pid *big.Int, _user common.Address) (struct {
	RequestAmount         *big.Int
	PendingWithdrawAmount *big.Int
}, error) {
	return _RCCStake.Contract.WithdrawAmount(&_RCCStake.CallOpts, _pid, _user)
}

// WithdrawAmount is a free data retrieval call binding the contract method 0xff423357.
//
// Solidity: function withdrawAmount(uint256 _pid, address _user) view returns(uint256 requestAmount, uint256 pendingWithdrawAmount)
func (_RCCStake *RCCStakeCallerSession) WithdrawAmount(_pid *big.Int, _user common.Address) (struct {
	RequestAmount         *big.Int
	PendingWithdrawAmount *big.Int
}, error) {
	return _RCCStake.Contract.WithdrawAmount(&_RCCStake.CallOpts, _pid, _user)
}

// WithdrawPaused is a free data retrieval call binding the contract method 0x2f3ffb9f.
//
// Solidity: function withdrawPaused() view returns(bool)
func (_RCCStake *RCCStakeCaller) WithdrawPaused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _RCCStake.contract.Call(opts, &out, "withdrawPaused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// WithdrawPaused is a free data retrieval call binding the contract method 0x2f3ffb9f.
//
// Solidity: function withdrawPaused() view returns(bool)
func (_RCCStake *RCCStakeSession) WithdrawPaused() (bool, error) {
	return _RCCStake.Contract.WithdrawPaused(&_RCCStake.CallOpts)
}

// WithdrawPaused is a free data retrieval call binding the contract method 0x2f3ffb9f.
//
// Solidity: function withdrawPaused() view returns(bool)
func (_RCCStake *RCCStakeCallerSession) WithdrawPaused() (bool, error) {
	return _RCCStake.Contract.WithdrawPaused(&_RCCStake.CallOpts)
}

// AddPool is a paid mutator transaction binding the contract method 0xb6d9d919.
//
// Solidity: function addPool(address _stTokenAddress, uint256 _poolWeight, uint256 _minDepositAmount, uint256 _unstakeLockedBlocks, bool _withUpdate) returns()
func (_RCCStake *RCCStakeTransactor) AddPool(opts *bind.TransactOpts, _stTokenAddress common.Address, _poolWeight *big.Int, _minDepositAmount *big.Int, _unstakeLockedBlocks *big.Int, _withUpdate bool) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "addPool", _stTokenAddress, _poolWeight, _minDepositAmount, _unstakeLockedBlocks, _withUpdate)
}

// AddPool is a paid mutator transaction binding the contract method 0xb6d9d919.
//
// Solidity: function addPool(address _stTokenAddress, uint256 _poolWeight, uint256 _minDepositAmount, uint256 _unstakeLockedBlocks, bool _withUpdate) returns()
func (_RCCStake *RCCStakeSession) AddPool(_stTokenAddress common.Address, _poolWeight *big.Int, _minDepositAmount *big.Int, _unstakeLockedBlocks *big.Int, _withUpdate bool) (*types.Transaction, error) {
	return _RCCStake.Contract.AddPool(&_RCCStake.TransactOpts, _stTokenAddress, _poolWeight, _minDepositAmount, _unstakeLockedBlocks, _withUpdate)
}

// AddPool is a paid mutator transaction binding the contract method 0xb6d9d919.
//
// Solidity: function addPool(address _stTokenAddress, uint256 _poolWeight, uint256 _minDepositAmount, uint256 _unstakeLockedBlocks, bool _withUpdate) returns()
func (_RCCStake *RCCStakeTransactorSession) AddPool(_stTokenAddress common.Address, _poolWeight *big.Int, _minDepositAmount *big.Int, _unstakeLockedBlocks *big.Int, _withUpdate bool) (*types.Transaction, error) {
	return _RCCStake.Contract.AddPool(&_RCCStake.TransactOpts, _stTokenAddress, _poolWeight, _minDepositAmount, _unstakeLockedBlocks, _withUpdate)
}

// Claim is a paid mutator transaction binding the contract method 0x379607f5.
//
// Solidity: function claim(uint256 _pid) returns()
func (_RCCStake *RCCStakeTransactor) Claim(opts *bind.TransactOpts, _pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "claim", _pid)
}

// Claim is a paid mutator transaction binding the contract method 0x379607f5.
//
// Solidity: function claim(uint256 _pid) returns()
func (_RCCStake *RCCStakeSession) Claim(_pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Claim(&_RCCStake.TransactOpts, _pid)
}

// Claim is a paid mutator transaction binding the contract method 0x379607f5.
//
// Solidity: function claim(uint256 _pid) returns()
func (_RCCStake *RCCStakeTransactorSession) Claim(_pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Claim(&_RCCStake.TransactOpts, _pid)
}

// Deposit is a paid mutator transaction binding the contract method 0xe2bbb158.
//
// Solidity: function deposit(uint256 _pid, uint256 _amount) returns()
func (_RCCStake *RCCStakeTransactor) Deposit(opts *bind.TransactOpts, _pid *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "deposit", _pid, _amount)
}

// Deposit is a paid mutator transaction binding the contract method 0xe2bbb158.
//
// Solidity: function deposit(uint256 _pid, uint256 _amount) returns()
func (_RCCStake *RCCStakeSession) Deposit(_pid *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Deposit(&_RCCStake.TransactOpts, _pid, _amount)
}

// Deposit is a paid mutator transaction binding the contract method 0xe2bbb158.
//
// Solidity: function deposit(uint256 _pid, uint256 _amount) returns()
func (_RCCStake *RCCStakeTransactorSession) Deposit(_pid *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Deposit(&_RCCStake.TransactOpts, _pid, _amount)
}

// DepositETH is a paid mutator transaction binding the contract method 0xf6326fb3.
//
// Solidity: function depositETH() payable returns()
func (_RCCStake *RCCStakeTransactor) DepositETH(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "depositETH")
}

// DepositETH is a paid mutator transaction binding the contract method 0xf6326fb3.
//
// Solidity: function depositETH() payable returns()
func (_RCCStake *RCCStakeSession) DepositETH() (*types.Transaction, error) {
	return _RCCStake.Contract.DepositETH(&_RCCStake.TransactOpts)
}

// DepositETH is a paid mutator transaction binding the contract method 0xf6326fb3.
//
// Solidity: function depositETH() payable returns()
func (_RCCStake *RCCStakeTransactorSession) DepositETH() (*types.Transaction, error) {
	return _RCCStake.Contract.DepositETH(&_RCCStake.TransactOpts)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_RCCStake *RCCStakeTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_RCCStake *RCCStakeSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _RCCStake.Contract.GrantRole(&_RCCStake.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_RCCStake *RCCStakeTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _RCCStake.Contract.GrantRole(&_RCCStake.TransactOpts, role, account)
}

// Initialize is a paid mutator transaction binding the contract method 0x4ec81af1.
//
// Solidity: function initialize(address _RCC, uint256 _startBlock, uint256 _endBlock, uint256 _rccPerBlock) returns()
func (_RCCStake *RCCStakeTransactor) Initialize(opts *bind.TransactOpts, _RCC common.Address, _startBlock *big.Int, _endBlock *big.Int, _rccPerBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "initialize", _RCC, _startBlock, _endBlock, _rccPerBlock)
}

// Initialize is a paid mutator transaction binding the contract method 0x4ec81af1.
//
// Solidity: function initialize(address _RCC, uint256 _startBlock, uint256 _endBlock, uint256 _rccPerBlock) returns()
func (_RCCStake *RCCStakeSession) Initialize(_RCC common.Address, _startBlock *big.Int, _endBlock *big.Int, _rccPerBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Initialize(&_RCCStake.TransactOpts, _RCC, _startBlock, _endBlock, _rccPerBlock)
}

// Initialize is a paid mutator transaction binding the contract method 0x4ec81af1.
//
// Solidity: function initialize(address _RCC, uint256 _startBlock, uint256 _endBlock, uint256 _rccPerBlock) returns()
func (_RCCStake *RCCStakeTransactorSession) Initialize(_RCC common.Address, _startBlock *big.Int, _endBlock *big.Int, _rccPerBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Initialize(&_RCCStake.TransactOpts, _RCC, _startBlock, _endBlock, _rccPerBlock)
}

// MassUpdatePools is a paid mutator transaction binding the contract method 0x630b5ba1.
//
// Solidity: function massUpdatePools() returns()
func (_RCCStake *RCCStakeTransactor) MassUpdatePools(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "massUpdatePools")
}

// MassUpdatePools is a paid mutator transaction binding the contract method 0x630b5ba1.
//
// Solidity: function massUpdatePools() returns()
func (_RCCStake *RCCStakeSession) MassUpdatePools() (*types.Transaction, error) {
	return _RCCStake.Contract.MassUpdatePools(&_RCCStake.TransactOpts)
}

// MassUpdatePools is a paid mutator transaction binding the contract method 0x630b5ba1.
//
// Solidity: function massUpdatePools() returns()
func (_RCCStake *RCCStakeTransactorSession) MassUpdatePools() (*types.Transaction, error) {
	return _RCCStake.Contract.MassUpdatePools(&_RCCStake.TransactOpts)
}

// PauseClaim is a paid mutator transaction binding the contract method 0x8ff095f9.
//
// Solidity: function pauseClaim() returns()
func (_RCCStake *RCCStakeTransactor) PauseClaim(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "pauseClaim")
}

// PauseClaim is a paid mutator transaction binding the contract method 0x8ff095f9.
//
// Solidity: function pauseClaim() returns()
func (_RCCStake *RCCStakeSession) PauseClaim() (*types.Transaction, error) {
	return _RCCStake.Contract.PauseClaim(&_RCCStake.TransactOpts)
}

// PauseClaim is a paid mutator transaction binding the contract method 0x8ff095f9.
//
// Solidity: function pauseClaim() returns()
func (_RCCStake *RCCStakeTransactorSession) PauseClaim() (*types.Transaction, error) {
	return _RCCStake.Contract.PauseClaim(&_RCCStake.TransactOpts)
}

// PauseWithdraw is a paid mutator transaction binding the contract method 0x6155e3de.
//
// Solidity: function pauseWithdraw() returns()
func (_RCCStake *RCCStakeTransactor) PauseWithdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "pauseWithdraw")
}

// PauseWithdraw is a paid mutator transaction binding the contract method 0x6155e3de.
//
// Solidity: function pauseWithdraw() returns()
func (_RCCStake *RCCStakeSession) PauseWithdraw() (*types.Transaction, error) {
	return _RCCStake.Contract.PauseWithdraw(&_RCCStake.TransactOpts)
}

// PauseWithdraw is a paid mutator transaction binding the contract method 0x6155e3de.
//
// Solidity: function pauseWithdraw() returns()
func (_RCCStake *RCCStakeTransactorSession) PauseWithdraw() (*types.Transaction, error) {
	return _RCCStake.Contract.PauseWithdraw(&_RCCStake.TransactOpts)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address callerConfirmation) returns()
func (_RCCStake *RCCStakeTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, callerConfirmation common.Address) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "renounceRole", role, callerConfirmation)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address callerConfirmation) returns()
func (_RCCStake *RCCStakeSession) RenounceRole(role [32]byte, callerConfirmation common.Address) (*types.Transaction, error) {
	return _RCCStake.Contract.RenounceRole(&_RCCStake.TransactOpts, role, callerConfirmation)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address callerConfirmation) returns()
func (_RCCStake *RCCStakeTransactorSession) RenounceRole(role [32]byte, callerConfirmation common.Address) (*types.Transaction, error) {
	return _RCCStake.Contract.RenounceRole(&_RCCStake.TransactOpts, role, callerConfirmation)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_RCCStake *RCCStakeTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_RCCStake *RCCStakeSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _RCCStake.Contract.RevokeRole(&_RCCStake.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_RCCStake *RCCStakeTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _RCCStake.Contract.RevokeRole(&_RCCStake.TransactOpts, role, account)
}

// SetEndBlock is a paid mutator transaction binding the contract method 0xc713aa94.
//
// Solidity: function setEndBlock(uint256 _endBlock) returns()
func (_RCCStake *RCCStakeTransactor) SetEndBlock(opts *bind.TransactOpts, _endBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "setEndBlock", _endBlock)
}

// SetEndBlock is a paid mutator transaction binding the contract method 0xc713aa94.
//
// Solidity: function setEndBlock(uint256 _endBlock) returns()
func (_RCCStake *RCCStakeSession) SetEndBlock(_endBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.SetEndBlock(&_RCCStake.TransactOpts, _endBlock)
}

// SetEndBlock is a paid mutator transaction binding the contract method 0xc713aa94.
//
// Solidity: function setEndBlock(uint256 _endBlock) returns()
func (_RCCStake *RCCStakeTransactorSession) SetEndBlock(_endBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.SetEndBlock(&_RCCStake.TransactOpts, _endBlock)
}

// SetPoolWeight is a paid mutator transaction binding the contract method 0xfad07ece.
//
// Solidity: function setPoolWeight(uint256 _pid, uint256 _poolWeight, bool _withUpdate) returns()
func (_RCCStake *RCCStakeTransactor) SetPoolWeight(opts *bind.TransactOpts, _pid *big.Int, _poolWeight *big.Int, _withUpdate bool) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "setPoolWeight", _pid, _poolWeight, _withUpdate)
}

// SetPoolWeight is a paid mutator transaction binding the contract method 0xfad07ece.
//
// Solidity: function setPoolWeight(uint256 _pid, uint256 _poolWeight, bool _withUpdate) returns()
func (_RCCStake *RCCStakeSession) SetPoolWeight(_pid *big.Int, _poolWeight *big.Int, _withUpdate bool) (*types.Transaction, error) {
	return _RCCStake.Contract.SetPoolWeight(&_RCCStake.TransactOpts, _pid, _poolWeight, _withUpdate)
}

// SetPoolWeight is a paid mutator transaction binding the contract method 0xfad07ece.
//
// Solidity: function setPoolWeight(uint256 _pid, uint256 _poolWeight, bool _withUpdate) returns()
func (_RCCStake *RCCStakeTransactorSession) SetPoolWeight(_pid *big.Int, _poolWeight *big.Int, _withUpdate bool) (*types.Transaction, error) {
	return _RCCStake.Contract.SetPoolWeight(&_RCCStake.TransactOpts, _pid, _poolWeight, _withUpdate)
}

// SetRCC is a paid mutator transaction binding the contract method 0xf5485d32.
//
// Solidity: function setRCC(address _RCC) returns()
func (_RCCStake *RCCStakeTransactor) SetRCC(opts *bind.TransactOpts, _RCC common.Address) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "setRCC", _RCC)
}

// SetRCC is a paid mutator transaction binding the contract method 0xf5485d32.
//
// Solidity: function setRCC(address _RCC) returns()
func (_RCCStake *RCCStakeSession) SetRCC(_RCC common.Address) (*types.Transaction, error) {
	return _RCCStake.Contract.SetRCC(&_RCCStake.TransactOpts, _RCC)
}

// SetRCC is a paid mutator transaction binding the contract method 0xf5485d32.
//
// Solidity: function setRCC(address _RCC) returns()
func (_RCCStake *RCCStakeTransactorSession) SetRCC(_RCC common.Address) (*types.Transaction, error) {
	return _RCCStake.Contract.SetRCC(&_RCCStake.TransactOpts, _RCC)
}

// SetRCCPerBlock is a paid mutator transaction binding the contract method 0xbed66c08.
//
// Solidity: function setRCCPerBlock(uint256 _rccPerBlock) returns()
func (_RCCStake *RCCStakeTransactor) SetRCCPerBlock(opts *bind.TransactOpts, _rccPerBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "setRCCPerBlock", _rccPerBlock)
}

// SetRCCPerBlock is a paid mutator transaction binding the contract method 0xbed66c08.
//
// Solidity: function setRCCPerBlock(uint256 _rccPerBlock) returns()
func (_RCCStake *RCCStakeSession) SetRCCPerBlock(_rccPerBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.SetRCCPerBlock(&_RCCStake.TransactOpts, _rccPerBlock)
}

// SetRCCPerBlock is a paid mutator transaction binding the contract method 0xbed66c08.
//
// Solidity: function setRCCPerBlock(uint256 _rccPerBlock) returns()
func (_RCCStake *RCCStakeTransactorSession) SetRCCPerBlock(_rccPerBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.SetRCCPerBlock(&_RCCStake.TransactOpts, _rccPerBlock)
}

// SetStartBlock is a paid mutator transaction binding the contract method 0xf35e4a6e.
//
// Solidity: function setStartBlock(uint256 _startBlock) returns()
func (_RCCStake *RCCStakeTransactor) SetStartBlock(opts *bind.TransactOpts, _startBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "setStartBlock", _startBlock)
}

// SetStartBlock is a paid mutator transaction binding the contract method 0xf35e4a6e.
//
// Solidity: function setStartBlock(uint256 _startBlock) returns()
func (_RCCStake *RCCStakeSession) SetStartBlock(_startBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.SetStartBlock(&_RCCStake.TransactOpts, _startBlock)
}

// SetStartBlock is a paid mutator transaction binding the contract method 0xf35e4a6e.
//
// Solidity: function setStartBlock(uint256 _startBlock) returns()
func (_RCCStake *RCCStakeTransactorSession) SetStartBlock(_startBlock *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.SetStartBlock(&_RCCStake.TransactOpts, _startBlock)
}

// UnpauseClaim is a paid mutator transaction binding the contract method 0xde065caa.
//
// Solidity: function unpauseClaim() returns()
func (_RCCStake *RCCStakeTransactor) UnpauseClaim(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "unpauseClaim")
}

// UnpauseClaim is a paid mutator transaction binding the contract method 0xde065caa.
//
// Solidity: function unpauseClaim() returns()
func (_RCCStake *RCCStakeSession) UnpauseClaim() (*types.Transaction, error) {
	return _RCCStake.Contract.UnpauseClaim(&_RCCStake.TransactOpts)
}

// UnpauseClaim is a paid mutator transaction binding the contract method 0xde065caa.
//
// Solidity: function unpauseClaim() returns()
func (_RCCStake *RCCStakeTransactorSession) UnpauseClaim() (*types.Transaction, error) {
	return _RCCStake.Contract.UnpauseClaim(&_RCCStake.TransactOpts)
}

// UnpauseWithdraw is a paid mutator transaction binding the contract method 0x5bb6d007.
//
// Solidity: function unpauseWithdraw() returns()
func (_RCCStake *RCCStakeTransactor) UnpauseWithdraw(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "unpauseWithdraw")
}

// UnpauseWithdraw is a paid mutator transaction binding the contract method 0x5bb6d007.
//
// Solidity: function unpauseWithdraw() returns()
func (_RCCStake *RCCStakeSession) UnpauseWithdraw() (*types.Transaction, error) {
	return _RCCStake.Contract.UnpauseWithdraw(&_RCCStake.TransactOpts)
}

// UnpauseWithdraw is a paid mutator transaction binding the contract method 0x5bb6d007.
//
// Solidity: function unpauseWithdraw() returns()
func (_RCCStake *RCCStakeTransactorSession) UnpauseWithdraw() (*types.Transaction, error) {
	return _RCCStake.Contract.UnpauseWithdraw(&_RCCStake.TransactOpts)
}

// Unstake is a paid mutator transaction binding the contract method 0x9e2c8a5b.
//
// Solidity: function unstake(uint256 _pid, uint256 _amount) returns()
func (_RCCStake *RCCStakeTransactor) Unstake(opts *bind.TransactOpts, _pid *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "unstake", _pid, _amount)
}

// Unstake is a paid mutator transaction binding the contract method 0x9e2c8a5b.
//
// Solidity: function unstake(uint256 _pid, uint256 _amount) returns()
func (_RCCStake *RCCStakeSession) Unstake(_pid *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Unstake(&_RCCStake.TransactOpts, _pid, _amount)
}

// Unstake is a paid mutator transaction binding the contract method 0x9e2c8a5b.
//
// Solidity: function unstake(uint256 _pid, uint256 _amount) returns()
func (_RCCStake *RCCStakeTransactorSession) Unstake(_pid *big.Int, _amount *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Unstake(&_RCCStake.TransactOpts, _pid, _amount)
}

// UpdatePool is a paid mutator transaction binding the contract method 0x51eb05a6.
//
// Solidity: function updatePool(uint256 _pid) returns()
func (_RCCStake *RCCStakeTransactor) UpdatePool(opts *bind.TransactOpts, _pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "updatePool", _pid)
}

// UpdatePool is a paid mutator transaction binding the contract method 0x51eb05a6.
//
// Solidity: function updatePool(uint256 _pid) returns()
func (_RCCStake *RCCStakeSession) UpdatePool(_pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.UpdatePool(&_RCCStake.TransactOpts, _pid)
}

// UpdatePool is a paid mutator transaction binding the contract method 0x51eb05a6.
//
// Solidity: function updatePool(uint256 _pid) returns()
func (_RCCStake *RCCStakeTransactorSession) UpdatePool(_pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.UpdatePool(&_RCCStake.TransactOpts, _pid)
}

// UpdatePool0 is a paid mutator transaction binding the contract method 0xd86c0444.
//
// Solidity: function updatePool(uint256 _pid, uint256 _minDepositAmount, uint256 _unstakeLockedBlocks) returns()
func (_RCCStake *RCCStakeTransactor) UpdatePool0(opts *bind.TransactOpts, _pid *big.Int, _minDepositAmount *big.Int, _unstakeLockedBlocks *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "updatePool0", _pid, _minDepositAmount, _unstakeLockedBlocks)
}

// UpdatePool0 is a paid mutator transaction binding the contract method 0xd86c0444.
//
// Solidity: function updatePool(uint256 _pid, uint256 _minDepositAmount, uint256 _unstakeLockedBlocks) returns()
func (_RCCStake *RCCStakeSession) UpdatePool0(_pid *big.Int, _minDepositAmount *big.Int, _unstakeLockedBlocks *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.UpdatePool0(&_RCCStake.TransactOpts, _pid, _minDepositAmount, _unstakeLockedBlocks)
}

// UpdatePool0 is a paid mutator transaction binding the contract method 0xd86c0444.
//
// Solidity: function updatePool(uint256 _pid, uint256 _minDepositAmount, uint256 _unstakeLockedBlocks) returns()
func (_RCCStake *RCCStakeTransactorSession) UpdatePool0(_pid *big.Int, _minDepositAmount *big.Int, _unstakeLockedBlocks *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.UpdatePool0(&_RCCStake.TransactOpts, _pid, _minDepositAmount, _unstakeLockedBlocks)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_RCCStake *RCCStakeTransactor) UpgradeToAndCall(opts *bind.TransactOpts, newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "upgradeToAndCall", newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_RCCStake *RCCStakeSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _RCCStake.Contract.UpgradeToAndCall(&_RCCStake.TransactOpts, newImplementation, data)
}

// UpgradeToAndCall is a paid mutator transaction binding the contract method 0x4f1ef286.
//
// Solidity: function upgradeToAndCall(address newImplementation, bytes data) payable returns()
func (_RCCStake *RCCStakeTransactorSession) UpgradeToAndCall(newImplementation common.Address, data []byte) (*types.Transaction, error) {
	return _RCCStake.Contract.UpgradeToAndCall(&_RCCStake.TransactOpts, newImplementation, data)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 _pid) returns()
func (_RCCStake *RCCStakeTransactor) Withdraw(opts *bind.TransactOpts, _pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.contract.Transact(opts, "withdraw", _pid)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 _pid) returns()
func (_RCCStake *RCCStakeSession) Withdraw(_pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Withdraw(&_RCCStake.TransactOpts, _pid)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 _pid) returns()
func (_RCCStake *RCCStakeTransactorSession) Withdraw(_pid *big.Int) (*types.Transaction, error) {
	return _RCCStake.Contract.Withdraw(&_RCCStake.TransactOpts, _pid)
}

// RCCStakeAddPoolIterator is returned from FilterAddPool and is used to iterate over the raw logs and unpacked data for AddPool events raised by the RCCStake contract.
type RCCStakeAddPoolIterator struct {
	Event *RCCStakeAddPool // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeAddPoolIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeAddPool)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeAddPool)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeAddPoolIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeAddPoolIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeAddPool represents a AddPool event raised by the RCCStake contract.
type RCCStakeAddPool struct {
	StTokenAddress      common.Address
	PoolWeight          *big.Int
	LastRewardBlock     *big.Int
	MinDepositAmount    *big.Int
	UnstakeLockedBlocks *big.Int
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterAddPool is a free log retrieval operation binding the contract event 0x0fa296fce13e7a0e622b3a892e66220c248337289483a3cfa4130cde0caa1346.
//
// Solidity: event AddPool(address indexed stTokenAddress, uint256 indexed poolWeight, uint256 indexed lastRewardBlock, uint256 minDepositAmount, uint256 unstakeLockedBlocks)
func (_RCCStake *RCCStakeFilterer) FilterAddPool(opts *bind.FilterOpts, stTokenAddress []common.Address, poolWeight []*big.Int, lastRewardBlock []*big.Int) (*RCCStakeAddPoolIterator, error) {

	var stTokenAddressRule []interface{}
	for _, stTokenAddressItem := range stTokenAddress {
		stTokenAddressRule = append(stTokenAddressRule, stTokenAddressItem)
	}
	var poolWeightRule []interface{}
	for _, poolWeightItem := range poolWeight {
		poolWeightRule = append(poolWeightRule, poolWeightItem)
	}
	var lastRewardBlockRule []interface{}
	for _, lastRewardBlockItem := range lastRewardBlock {
		lastRewardBlockRule = append(lastRewardBlockRule, lastRewardBlockItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "AddPool", stTokenAddressRule, poolWeightRule, lastRewardBlockRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeAddPoolIterator{contract: _RCCStake.contract, event: "AddPool", logs: logs, sub: sub}, nil
}

// WatchAddPool is a free log subscription operation binding the contract event 0x0fa296fce13e7a0e622b3a892e66220c248337289483a3cfa4130cde0caa1346.
//
// Solidity: event AddPool(address indexed stTokenAddress, uint256 indexed poolWeight, uint256 indexed lastRewardBlock, uint256 minDepositAmount, uint256 unstakeLockedBlocks)
func (_RCCStake *RCCStakeFilterer) WatchAddPool(opts *bind.WatchOpts, sink chan<- *RCCStakeAddPool, stTokenAddress []common.Address, poolWeight []*big.Int, lastRewardBlock []*big.Int) (event.Subscription, error) {

	var stTokenAddressRule []interface{}
	for _, stTokenAddressItem := range stTokenAddress {
		stTokenAddressRule = append(stTokenAddressRule, stTokenAddressItem)
	}
	var poolWeightRule []interface{}
	for _, poolWeightItem := range poolWeight {
		poolWeightRule = append(poolWeightRule, poolWeightItem)
	}
	var lastRewardBlockRule []interface{}
	for _, lastRewardBlockItem := range lastRewardBlock {
		lastRewardBlockRule = append(lastRewardBlockRule, lastRewardBlockItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "AddPool", stTokenAddressRule, poolWeightRule, lastRewardBlockRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeAddPool)
				if err := _RCCStake.contract.UnpackLog(event, "AddPool", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAddPool is a log parse operation binding the contract event 0x0fa296fce13e7a0e622b3a892e66220c248337289483a3cfa4130cde0caa1346.
//
// Solidity: event AddPool(address indexed stTokenAddress, uint256 indexed poolWeight, uint256 indexed lastRewardBlock, uint256 minDepositAmount, uint256 unstakeLockedBlocks)
func (_RCCStake *RCCStakeFilterer) ParseAddPool(log types.Log) (*RCCStakeAddPool, error) {
	event := new(RCCStakeAddPool)
	if err := _RCCStake.contract.UnpackLog(event, "AddPool", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeClaimIterator is returned from FilterClaim and is used to iterate over the raw logs and unpacked data for Claim events raised by the RCCStake contract.
type RCCStakeClaimIterator struct {
	Event *RCCStakeClaim // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeClaimIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeClaim)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeClaim)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeClaimIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeClaimIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeClaim represents a Claim event raised by the RCCStake contract.
type RCCStakeClaim struct {
	User      common.Address
	PoolId    *big.Int
	RccReward *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterClaim is a free log retrieval operation binding the contract event 0x34fcbac0073d7c3d388e51312faf357774904998eeb8fca628b9e6f65ee1cbf7.
//
// Solidity: event Claim(address indexed user, uint256 indexed poolId, uint256 rccReward)
func (_RCCStake *RCCStakeFilterer) FilterClaim(opts *bind.FilterOpts, user []common.Address, poolId []*big.Int) (*RCCStakeClaimIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "Claim", userRule, poolIdRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeClaimIterator{contract: _RCCStake.contract, event: "Claim", logs: logs, sub: sub}, nil
}

// WatchClaim is a free log subscription operation binding the contract event 0x34fcbac0073d7c3d388e51312faf357774904998eeb8fca628b9e6f65ee1cbf7.
//
// Solidity: event Claim(address indexed user, uint256 indexed poolId, uint256 rccReward)
func (_RCCStake *RCCStakeFilterer) WatchClaim(opts *bind.WatchOpts, sink chan<- *RCCStakeClaim, user []common.Address, poolId []*big.Int) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "Claim", userRule, poolIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeClaim)
				if err := _RCCStake.contract.UnpackLog(event, "Claim", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseClaim is a log parse operation binding the contract event 0x34fcbac0073d7c3d388e51312faf357774904998eeb8fca628b9e6f65ee1cbf7.
//
// Solidity: event Claim(address indexed user, uint256 indexed poolId, uint256 rccReward)
func (_RCCStake *RCCStakeFilterer) ParseClaim(log types.Log) (*RCCStakeClaim, error) {
	event := new(RCCStakeClaim)
	if err := _RCCStake.contract.UnpackLog(event, "Claim", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeDepositIterator is returned from FilterDeposit and is used to iterate over the raw logs and unpacked data for Deposit events raised by the RCCStake contract.
type RCCStakeDepositIterator struct {
	Event *RCCStakeDeposit // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeDepositIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeDeposit)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeDeposit)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeDepositIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeDepositIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeDeposit represents a Deposit event raised by the RCCStake contract.
type RCCStakeDeposit struct {
	User   common.Address
	PoolId *big.Int
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDeposit is a free log retrieval operation binding the contract event 0x90890809c654f11d6e72a28fa60149770a0d11ec6c92319d6ceb2bb0a4ea1a15.
//
// Solidity: event Deposit(address indexed user, uint256 indexed poolId, uint256 amount)
func (_RCCStake *RCCStakeFilterer) FilterDeposit(opts *bind.FilterOpts, user []common.Address, poolId []*big.Int) (*RCCStakeDepositIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "Deposit", userRule, poolIdRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeDepositIterator{contract: _RCCStake.contract, event: "Deposit", logs: logs, sub: sub}, nil
}

// WatchDeposit is a free log subscription operation binding the contract event 0x90890809c654f11d6e72a28fa60149770a0d11ec6c92319d6ceb2bb0a4ea1a15.
//
// Solidity: event Deposit(address indexed user, uint256 indexed poolId, uint256 amount)
func (_RCCStake *RCCStakeFilterer) WatchDeposit(opts *bind.WatchOpts, sink chan<- *RCCStakeDeposit, user []common.Address, poolId []*big.Int) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "Deposit", userRule, poolIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeDeposit)
				if err := _RCCStake.contract.UnpackLog(event, "Deposit", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposit is a log parse operation binding the contract event 0x90890809c654f11d6e72a28fa60149770a0d11ec6c92319d6ceb2bb0a4ea1a15.
//
// Solidity: event Deposit(address indexed user, uint256 indexed poolId, uint256 amount)
func (_RCCStake *RCCStakeFilterer) ParseDeposit(log types.Log) (*RCCStakeDeposit, error) {
	event := new(RCCStakeDeposit)
	if err := _RCCStake.contract.UnpackLog(event, "Deposit", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the RCCStake contract.
type RCCStakeInitializedIterator struct {
	Event *RCCStakeInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeInitialized represents a Initialized event raised by the RCCStake contract.
type RCCStakeInitialized struct {
	Version uint64
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_RCCStake *RCCStakeFilterer) FilterInitialized(opts *bind.FilterOpts) (*RCCStakeInitializedIterator, error) {

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &RCCStakeInitializedIterator{contract: _RCCStake.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_RCCStake *RCCStakeFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *RCCStakeInitialized) (event.Subscription, error) {

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeInitialized)
				if err := _RCCStake.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2.
//
// Solidity: event Initialized(uint64 version)
func (_RCCStake *RCCStakeFilterer) ParseInitialized(log types.Log) (*RCCStakeInitialized, error) {
	event := new(RCCStakeInitialized)
	if err := _RCCStake.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakePauseClaimIterator is returned from FilterPauseClaim and is used to iterate over the raw logs and unpacked data for PauseClaim events raised by the RCCStake contract.
type RCCStakePauseClaimIterator struct {
	Event *RCCStakePauseClaim // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakePauseClaimIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakePauseClaim)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakePauseClaim)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakePauseClaimIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakePauseClaimIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakePauseClaim represents a PauseClaim event raised by the RCCStake contract.
type RCCStakePauseClaim struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPauseClaim is a free log retrieval operation binding the contract event 0x6d73d6b34c378ab3bf6630206d60b7882801b91d03ee20d016ff0d5054db81e1.
//
// Solidity: event PauseClaim()
func (_RCCStake *RCCStakeFilterer) FilterPauseClaim(opts *bind.FilterOpts) (*RCCStakePauseClaimIterator, error) {

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "PauseClaim")
	if err != nil {
		return nil, err
	}
	return &RCCStakePauseClaimIterator{contract: _RCCStake.contract, event: "PauseClaim", logs: logs, sub: sub}, nil
}

// WatchPauseClaim is a free log subscription operation binding the contract event 0x6d73d6b34c378ab3bf6630206d60b7882801b91d03ee20d016ff0d5054db81e1.
//
// Solidity: event PauseClaim()
func (_RCCStake *RCCStakeFilterer) WatchPauseClaim(opts *bind.WatchOpts, sink chan<- *RCCStakePauseClaim) (event.Subscription, error) {

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "PauseClaim")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakePauseClaim)
				if err := _RCCStake.contract.UnpackLog(event, "PauseClaim", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauseClaim is a log parse operation binding the contract event 0x6d73d6b34c378ab3bf6630206d60b7882801b91d03ee20d016ff0d5054db81e1.
//
// Solidity: event PauseClaim()
func (_RCCStake *RCCStakeFilterer) ParsePauseClaim(log types.Log) (*RCCStakePauseClaim, error) {
	event := new(RCCStakePauseClaim)
	if err := _RCCStake.contract.UnpackLog(event, "PauseClaim", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakePauseWithdrawIterator is returned from FilterPauseWithdraw and is used to iterate over the raw logs and unpacked data for PauseWithdraw events raised by the RCCStake contract.
type RCCStakePauseWithdrawIterator struct {
	Event *RCCStakePauseWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakePauseWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakePauseWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakePauseWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakePauseWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakePauseWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakePauseWithdraw represents a PauseWithdraw event raised by the RCCStake contract.
type RCCStakePauseWithdraw struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterPauseWithdraw is a free log retrieval operation binding the contract event 0x8099f593a6aaecd68b6494933cd71f703376ac3975be83692e1b7d800abf6837.
//
// Solidity: event PauseWithdraw()
func (_RCCStake *RCCStakeFilterer) FilterPauseWithdraw(opts *bind.FilterOpts) (*RCCStakePauseWithdrawIterator, error) {

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "PauseWithdraw")
	if err != nil {
		return nil, err
	}
	return &RCCStakePauseWithdrawIterator{contract: _RCCStake.contract, event: "PauseWithdraw", logs: logs, sub: sub}, nil
}

// WatchPauseWithdraw is a free log subscription operation binding the contract event 0x8099f593a6aaecd68b6494933cd71f703376ac3975be83692e1b7d800abf6837.
//
// Solidity: event PauseWithdraw()
func (_RCCStake *RCCStakeFilterer) WatchPauseWithdraw(opts *bind.WatchOpts, sink chan<- *RCCStakePauseWithdraw) (event.Subscription, error) {

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "PauseWithdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakePauseWithdraw)
				if err := _RCCStake.contract.UnpackLog(event, "PauseWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauseWithdraw is a log parse operation binding the contract event 0x8099f593a6aaecd68b6494933cd71f703376ac3975be83692e1b7d800abf6837.
//
// Solidity: event PauseWithdraw()
func (_RCCStake *RCCStakeFilterer) ParsePauseWithdraw(log types.Log) (*RCCStakePauseWithdraw, error) {
	event := new(RCCStakePauseWithdraw)
	if err := _RCCStake.contract.UnpackLog(event, "PauseWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakePausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the RCCStake contract.
type RCCStakePausedIterator struct {
	Event *RCCStakePaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakePausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakePaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakePaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakePausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakePausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakePaused represents a Paused event raised by the RCCStake contract.
type RCCStakePaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_RCCStake *RCCStakeFilterer) FilterPaused(opts *bind.FilterOpts) (*RCCStakePausedIterator, error) {

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &RCCStakePausedIterator{contract: _RCCStake.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_RCCStake *RCCStakeFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *RCCStakePaused) (event.Subscription, error) {

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakePaused)
				if err := _RCCStake.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_RCCStake *RCCStakeFilterer) ParsePaused(log types.Log) (*RCCStakePaused, error) {
	event := new(RCCStakePaused)
	if err := _RCCStake.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeRequestUnstakeIterator is returned from FilterRequestUnstake and is used to iterate over the raw logs and unpacked data for RequestUnstake events raised by the RCCStake contract.
type RCCStakeRequestUnstakeIterator struct {
	Event *RCCStakeRequestUnstake // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeRequestUnstakeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeRequestUnstake)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeRequestUnstake)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeRequestUnstakeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeRequestUnstakeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeRequestUnstake represents a RequestUnstake event raised by the RCCStake contract.
type RCCStakeRequestUnstake struct {
	User   common.Address
	PoolId *big.Int
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRequestUnstake is a free log retrieval operation binding the contract event 0xc80277265097707f6f12a4ac4c09d46c9926e2eea2536f63616cb04d9fcad7d6.
//
// Solidity: event RequestUnstake(address indexed user, uint256 indexed poolId, uint256 amount)
func (_RCCStake *RCCStakeFilterer) FilterRequestUnstake(opts *bind.FilterOpts, user []common.Address, poolId []*big.Int) (*RCCStakeRequestUnstakeIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "RequestUnstake", userRule, poolIdRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeRequestUnstakeIterator{contract: _RCCStake.contract, event: "RequestUnstake", logs: logs, sub: sub}, nil
}

// WatchRequestUnstake is a free log subscription operation binding the contract event 0xc80277265097707f6f12a4ac4c09d46c9926e2eea2536f63616cb04d9fcad7d6.
//
// Solidity: event RequestUnstake(address indexed user, uint256 indexed poolId, uint256 amount)
func (_RCCStake *RCCStakeFilterer) WatchRequestUnstake(opts *bind.WatchOpts, sink chan<- *RCCStakeRequestUnstake, user []common.Address, poolId []*big.Int) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "RequestUnstake", userRule, poolIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeRequestUnstake)
				if err := _RCCStake.contract.UnpackLog(event, "RequestUnstake", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestUnstake is a log parse operation binding the contract event 0xc80277265097707f6f12a4ac4c09d46c9926e2eea2536f63616cb04d9fcad7d6.
//
// Solidity: event RequestUnstake(address indexed user, uint256 indexed poolId, uint256 amount)
func (_RCCStake *RCCStakeFilterer) ParseRequestUnstake(log types.Log) (*RCCStakeRequestUnstake, error) {
	event := new(RCCStakeRequestUnstake)
	if err := _RCCStake.contract.UnpackLog(event, "RequestUnstake", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the RCCStake contract.
type RCCStakeRoleAdminChangedIterator struct {
	Event *RCCStakeRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeRoleAdminChanged represents a RoleAdminChanged event raised by the RCCStake contract.
type RCCStakeRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_RCCStake *RCCStakeFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*RCCStakeRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeRoleAdminChangedIterator{contract: _RCCStake.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_RCCStake *RCCStakeFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *RCCStakeRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeRoleAdminChanged)
				if err := _RCCStake.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_RCCStake *RCCStakeFilterer) ParseRoleAdminChanged(log types.Log) (*RCCStakeRoleAdminChanged, error) {
	event := new(RCCStakeRoleAdminChanged)
	if err := _RCCStake.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the RCCStake contract.
type RCCStakeRoleGrantedIterator struct {
	Event *RCCStakeRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeRoleGranted represents a RoleGranted event raised by the RCCStake contract.
type RCCStakeRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_RCCStake *RCCStakeFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*RCCStakeRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeRoleGrantedIterator{contract: _RCCStake.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_RCCStake *RCCStakeFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *RCCStakeRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeRoleGranted)
				if err := _RCCStake.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_RCCStake *RCCStakeFilterer) ParseRoleGranted(log types.Log) (*RCCStakeRoleGranted, error) {
	event := new(RCCStakeRoleGranted)
	if err := _RCCStake.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the RCCStake contract.
type RCCStakeRoleRevokedIterator struct {
	Event *RCCStakeRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeRoleRevoked represents a RoleRevoked event raised by the RCCStake contract.
type RCCStakeRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_RCCStake *RCCStakeFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*RCCStakeRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeRoleRevokedIterator{contract: _RCCStake.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_RCCStake *RCCStakeFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *RCCStakeRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeRoleRevoked)
				if err := _RCCStake.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_RCCStake *RCCStakeFilterer) ParseRoleRevoked(log types.Log) (*RCCStakeRoleRevoked, error) {
	event := new(RCCStakeRoleRevoked)
	if err := _RCCStake.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeSetEndBlockIterator is returned from FilterSetEndBlock and is used to iterate over the raw logs and unpacked data for SetEndBlock events raised by the RCCStake contract.
type RCCStakeSetEndBlockIterator struct {
	Event *RCCStakeSetEndBlock // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeSetEndBlockIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeSetEndBlock)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeSetEndBlock)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeSetEndBlockIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeSetEndBlockIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeSetEndBlock represents a SetEndBlock event raised by the RCCStake contract.
type RCCStakeSetEndBlock struct {
	EndBlock *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterSetEndBlock is a free log retrieval operation binding the contract event 0x1132c5baccb51da3d049fabc819697dc845fa224ad59d9b555507d6446b40850.
//
// Solidity: event SetEndBlock(uint256 indexed endBlock)
func (_RCCStake *RCCStakeFilterer) FilterSetEndBlock(opts *bind.FilterOpts, endBlock []*big.Int) (*RCCStakeSetEndBlockIterator, error) {

	var endBlockRule []interface{}
	for _, endBlockItem := range endBlock {
		endBlockRule = append(endBlockRule, endBlockItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "SetEndBlock", endBlockRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeSetEndBlockIterator{contract: _RCCStake.contract, event: "SetEndBlock", logs: logs, sub: sub}, nil
}

// WatchSetEndBlock is a free log subscription operation binding the contract event 0x1132c5baccb51da3d049fabc819697dc845fa224ad59d9b555507d6446b40850.
//
// Solidity: event SetEndBlock(uint256 indexed endBlock)
func (_RCCStake *RCCStakeFilterer) WatchSetEndBlock(opts *bind.WatchOpts, sink chan<- *RCCStakeSetEndBlock, endBlock []*big.Int) (event.Subscription, error) {

	var endBlockRule []interface{}
	for _, endBlockItem := range endBlock {
		endBlockRule = append(endBlockRule, endBlockItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "SetEndBlock", endBlockRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeSetEndBlock)
				if err := _RCCStake.contract.UnpackLog(event, "SetEndBlock", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetEndBlock is a log parse operation binding the contract event 0x1132c5baccb51da3d049fabc819697dc845fa224ad59d9b555507d6446b40850.
//
// Solidity: event SetEndBlock(uint256 indexed endBlock)
func (_RCCStake *RCCStakeFilterer) ParseSetEndBlock(log types.Log) (*RCCStakeSetEndBlock, error) {
	event := new(RCCStakeSetEndBlock)
	if err := _RCCStake.contract.UnpackLog(event, "SetEndBlock", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeSetPoolWeightIterator is returned from FilterSetPoolWeight and is used to iterate over the raw logs and unpacked data for SetPoolWeight events raised by the RCCStake contract.
type RCCStakeSetPoolWeightIterator struct {
	Event *RCCStakeSetPoolWeight // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeSetPoolWeightIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeSetPoolWeight)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeSetPoolWeight)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeSetPoolWeightIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeSetPoolWeightIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeSetPoolWeight represents a SetPoolWeight event raised by the RCCStake contract.
type RCCStakeSetPoolWeight struct {
	PoolId          *big.Int
	PoolWeight      *big.Int
	TotalPoolWeight *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSetPoolWeight is a free log retrieval operation binding the contract event 0x4b8fa3d6a87cb21d1bf4978bf60628ae358a28ac7f39de1751a481c6dd957617.
//
// Solidity: event SetPoolWeight(uint256 indexed poolId, uint256 indexed poolWeight, uint256 totalPoolWeight)
func (_RCCStake *RCCStakeFilterer) FilterSetPoolWeight(opts *bind.FilterOpts, poolId []*big.Int, poolWeight []*big.Int) (*RCCStakeSetPoolWeightIterator, error) {

	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}
	var poolWeightRule []interface{}
	for _, poolWeightItem := range poolWeight {
		poolWeightRule = append(poolWeightRule, poolWeightItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "SetPoolWeight", poolIdRule, poolWeightRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeSetPoolWeightIterator{contract: _RCCStake.contract, event: "SetPoolWeight", logs: logs, sub: sub}, nil
}

// WatchSetPoolWeight is a free log subscription operation binding the contract event 0x4b8fa3d6a87cb21d1bf4978bf60628ae358a28ac7f39de1751a481c6dd957617.
//
// Solidity: event SetPoolWeight(uint256 indexed poolId, uint256 indexed poolWeight, uint256 totalPoolWeight)
func (_RCCStake *RCCStakeFilterer) WatchSetPoolWeight(opts *bind.WatchOpts, sink chan<- *RCCStakeSetPoolWeight, poolId []*big.Int, poolWeight []*big.Int) (event.Subscription, error) {

	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}
	var poolWeightRule []interface{}
	for _, poolWeightItem := range poolWeight {
		poolWeightRule = append(poolWeightRule, poolWeightItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "SetPoolWeight", poolIdRule, poolWeightRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeSetPoolWeight)
				if err := _RCCStake.contract.UnpackLog(event, "SetPoolWeight", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetPoolWeight is a log parse operation binding the contract event 0x4b8fa3d6a87cb21d1bf4978bf60628ae358a28ac7f39de1751a481c6dd957617.
//
// Solidity: event SetPoolWeight(uint256 indexed poolId, uint256 indexed poolWeight, uint256 totalPoolWeight)
func (_RCCStake *RCCStakeFilterer) ParseSetPoolWeight(log types.Log) (*RCCStakeSetPoolWeight, error) {
	event := new(RCCStakeSetPoolWeight)
	if err := _RCCStake.contract.UnpackLog(event, "SetPoolWeight", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeSetRCCIterator is returned from FilterSetRCC and is used to iterate over the raw logs and unpacked data for SetRCC events raised by the RCCStake contract.
type RCCStakeSetRCCIterator struct {
	Event *RCCStakeSetRCC // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeSetRCCIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeSetRCC)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeSetRCC)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeSetRCCIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeSetRCCIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeSetRCC represents a SetRCC event raised by the RCCStake contract.
type RCCStakeSetRCC struct {
	RCC common.Address
	Raw types.Log // Blockchain specific contextual infos
}

// FilterSetRCC is a free log retrieval operation binding the contract event 0x153aae53b92218044bd5f43922617c6b253e50ac98a41b44c3acb5625ded3488.
//
// Solidity: event SetRCC(address indexed RCC)
func (_RCCStake *RCCStakeFilterer) FilterSetRCC(opts *bind.FilterOpts, RCC []common.Address) (*RCCStakeSetRCCIterator, error) {

	var RCCRule []interface{}
	for _, RCCItem := range RCC {
		RCCRule = append(RCCRule, RCCItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "SetRCC", RCCRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeSetRCCIterator{contract: _RCCStake.contract, event: "SetRCC", logs: logs, sub: sub}, nil
}

// WatchSetRCC is a free log subscription operation binding the contract event 0x153aae53b92218044bd5f43922617c6b253e50ac98a41b44c3acb5625ded3488.
//
// Solidity: event SetRCC(address indexed RCC)
func (_RCCStake *RCCStakeFilterer) WatchSetRCC(opts *bind.WatchOpts, sink chan<- *RCCStakeSetRCC, RCC []common.Address) (event.Subscription, error) {

	var RCCRule []interface{}
	for _, RCCItem := range RCC {
		RCCRule = append(RCCRule, RCCItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "SetRCC", RCCRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeSetRCC)
				if err := _RCCStake.contract.UnpackLog(event, "SetRCC", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetRCC is a log parse operation binding the contract event 0x153aae53b92218044bd5f43922617c6b253e50ac98a41b44c3acb5625ded3488.
//
// Solidity: event SetRCC(address indexed RCC)
func (_RCCStake *RCCStakeFilterer) ParseSetRCC(log types.Log) (*RCCStakeSetRCC, error) {
	event := new(RCCStakeSetRCC)
	if err := _RCCStake.contract.UnpackLog(event, "SetRCC", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeSetRCCPerBlockIterator is returned from FilterSetRCCPerBlock and is used to iterate over the raw logs and unpacked data for SetRCCPerBlock events raised by the RCCStake contract.
type RCCStakeSetRCCPerBlockIterator struct {
	Event *RCCStakeSetRCCPerBlock // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeSetRCCPerBlockIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeSetRCCPerBlock)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeSetRCCPerBlock)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeSetRCCPerBlockIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeSetRCCPerBlockIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeSetRCCPerBlock represents a SetRCCPerBlock event raised by the RCCStake contract.
type RCCStakeSetRCCPerBlock struct {
	RccPerBlock *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSetRCCPerBlock is a free log retrieval operation binding the contract event 0x4c70925b625536dd633f6bd2d615c67fddc2e7c63c31164047a981a0df3fee54.
//
// Solidity: event SetRCCPerBlock(uint256 indexed rccPerBlock)
func (_RCCStake *RCCStakeFilterer) FilterSetRCCPerBlock(opts *bind.FilterOpts, rccPerBlock []*big.Int) (*RCCStakeSetRCCPerBlockIterator, error) {

	var rccPerBlockRule []interface{}
	for _, rccPerBlockItem := range rccPerBlock {
		rccPerBlockRule = append(rccPerBlockRule, rccPerBlockItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "SetRCCPerBlock", rccPerBlockRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeSetRCCPerBlockIterator{contract: _RCCStake.contract, event: "SetRCCPerBlock", logs: logs, sub: sub}, nil
}

// WatchSetRCCPerBlock is a free log subscription operation binding the contract event 0x4c70925b625536dd633f6bd2d615c67fddc2e7c63c31164047a981a0df3fee54.
//
// Solidity: event SetRCCPerBlock(uint256 indexed rccPerBlock)
func (_RCCStake *RCCStakeFilterer) WatchSetRCCPerBlock(opts *bind.WatchOpts, sink chan<- *RCCStakeSetRCCPerBlock, rccPerBlock []*big.Int) (event.Subscription, error) {

	var rccPerBlockRule []interface{}
	for _, rccPerBlockItem := range rccPerBlock {
		rccPerBlockRule = append(rccPerBlockRule, rccPerBlockItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "SetRCCPerBlock", rccPerBlockRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeSetRCCPerBlock)
				if err := _RCCStake.contract.UnpackLog(event, "SetRCCPerBlock", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetRCCPerBlock is a log parse operation binding the contract event 0x4c70925b625536dd633f6bd2d615c67fddc2e7c63c31164047a981a0df3fee54.
//
// Solidity: event SetRCCPerBlock(uint256 indexed rccPerBlock)
func (_RCCStake *RCCStakeFilterer) ParseSetRCCPerBlock(log types.Log) (*RCCStakeSetRCCPerBlock, error) {
	event := new(RCCStakeSetRCCPerBlock)
	if err := _RCCStake.contract.UnpackLog(event, "SetRCCPerBlock", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeSetStartBlockIterator is returned from FilterSetStartBlock and is used to iterate over the raw logs and unpacked data for SetStartBlock events raised by the RCCStake contract.
type RCCStakeSetStartBlockIterator struct {
	Event *RCCStakeSetStartBlock // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeSetStartBlockIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeSetStartBlock)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeSetStartBlock)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeSetStartBlockIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeSetStartBlockIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeSetStartBlock represents a SetStartBlock event raised by the RCCStake contract.
type RCCStakeSetStartBlock struct {
	StartBlock *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterSetStartBlock is a free log retrieval operation binding the contract event 0x63b90b79f11a0f132bcb2c4a4ddd44abda45c1308a83b2919318df7f5f8b7be4.
//
// Solidity: event SetStartBlock(uint256 indexed startBlock)
func (_RCCStake *RCCStakeFilterer) FilterSetStartBlock(opts *bind.FilterOpts, startBlock []*big.Int) (*RCCStakeSetStartBlockIterator, error) {

	var startBlockRule []interface{}
	for _, startBlockItem := range startBlock {
		startBlockRule = append(startBlockRule, startBlockItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "SetStartBlock", startBlockRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeSetStartBlockIterator{contract: _RCCStake.contract, event: "SetStartBlock", logs: logs, sub: sub}, nil
}

// WatchSetStartBlock is a free log subscription operation binding the contract event 0x63b90b79f11a0f132bcb2c4a4ddd44abda45c1308a83b2919318df7f5f8b7be4.
//
// Solidity: event SetStartBlock(uint256 indexed startBlock)
func (_RCCStake *RCCStakeFilterer) WatchSetStartBlock(opts *bind.WatchOpts, sink chan<- *RCCStakeSetStartBlock, startBlock []*big.Int) (event.Subscription, error) {

	var startBlockRule []interface{}
	for _, startBlockItem := range startBlock {
		startBlockRule = append(startBlockRule, startBlockItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "SetStartBlock", startBlockRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeSetStartBlock)
				if err := _RCCStake.contract.UnpackLog(event, "SetStartBlock", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetStartBlock is a log parse operation binding the contract event 0x63b90b79f11a0f132bcb2c4a4ddd44abda45c1308a83b2919318df7f5f8b7be4.
//
// Solidity: event SetStartBlock(uint256 indexed startBlock)
func (_RCCStake *RCCStakeFilterer) ParseSetStartBlock(log types.Log) (*RCCStakeSetStartBlock, error) {
	event := new(RCCStakeSetStartBlock)
	if err := _RCCStake.contract.UnpackLog(event, "SetStartBlock", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeUnpauseClaimIterator is returned from FilterUnpauseClaim and is used to iterate over the raw logs and unpacked data for UnpauseClaim events raised by the RCCStake contract.
type RCCStakeUnpauseClaimIterator struct {
	Event *RCCStakeUnpauseClaim // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeUnpauseClaimIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeUnpauseClaim)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeUnpauseClaim)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeUnpauseClaimIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeUnpauseClaimIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeUnpauseClaim represents a UnpauseClaim event raised by the RCCStake contract.
type RCCStakeUnpauseClaim struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpauseClaim is a free log retrieval operation binding the contract event 0xe72cb12952f056e3e7496019725f20a13108ca420f67f1ee9c9cdab73fb8ce85.
//
// Solidity: event UnpauseClaim()
func (_RCCStake *RCCStakeFilterer) FilterUnpauseClaim(opts *bind.FilterOpts) (*RCCStakeUnpauseClaimIterator, error) {

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "UnpauseClaim")
	if err != nil {
		return nil, err
	}
	return &RCCStakeUnpauseClaimIterator{contract: _RCCStake.contract, event: "UnpauseClaim", logs: logs, sub: sub}, nil
}

// WatchUnpauseClaim is a free log subscription operation binding the contract event 0xe72cb12952f056e3e7496019725f20a13108ca420f67f1ee9c9cdab73fb8ce85.
//
// Solidity: event UnpauseClaim()
func (_RCCStake *RCCStakeFilterer) WatchUnpauseClaim(opts *bind.WatchOpts, sink chan<- *RCCStakeUnpauseClaim) (event.Subscription, error) {

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "UnpauseClaim")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeUnpauseClaim)
				if err := _RCCStake.contract.UnpackLog(event, "UnpauseClaim", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpauseClaim is a log parse operation binding the contract event 0xe72cb12952f056e3e7496019725f20a13108ca420f67f1ee9c9cdab73fb8ce85.
//
// Solidity: event UnpauseClaim()
func (_RCCStake *RCCStakeFilterer) ParseUnpauseClaim(log types.Log) (*RCCStakeUnpauseClaim, error) {
	event := new(RCCStakeUnpauseClaim)
	if err := _RCCStake.contract.UnpackLog(event, "UnpauseClaim", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeUnpauseWithdrawIterator is returned from FilterUnpauseWithdraw and is used to iterate over the raw logs and unpacked data for UnpauseWithdraw events raised by the RCCStake contract.
type RCCStakeUnpauseWithdrawIterator struct {
	Event *RCCStakeUnpauseWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeUnpauseWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeUnpauseWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeUnpauseWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeUnpauseWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeUnpauseWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeUnpauseWithdraw represents a UnpauseWithdraw event raised by the RCCStake contract.
type RCCStakeUnpauseWithdraw struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterUnpauseWithdraw is a free log retrieval operation binding the contract event 0x1c84bcaead48b692cc46b9b12e9a068951a59c99a2e2bf10b00b60b403cf12e2.
//
// Solidity: event UnpauseWithdraw()
func (_RCCStake *RCCStakeFilterer) FilterUnpauseWithdraw(opts *bind.FilterOpts) (*RCCStakeUnpauseWithdrawIterator, error) {

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "UnpauseWithdraw")
	if err != nil {
		return nil, err
	}
	return &RCCStakeUnpauseWithdrawIterator{contract: _RCCStake.contract, event: "UnpauseWithdraw", logs: logs, sub: sub}, nil
}

// WatchUnpauseWithdraw is a free log subscription operation binding the contract event 0x1c84bcaead48b692cc46b9b12e9a068951a59c99a2e2bf10b00b60b403cf12e2.
//
// Solidity: event UnpauseWithdraw()
func (_RCCStake *RCCStakeFilterer) WatchUnpauseWithdraw(opts *bind.WatchOpts, sink chan<- *RCCStakeUnpauseWithdraw) (event.Subscription, error) {

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "UnpauseWithdraw")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeUnpauseWithdraw)
				if err := _RCCStake.contract.UnpackLog(event, "UnpauseWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpauseWithdraw is a log parse operation binding the contract event 0x1c84bcaead48b692cc46b9b12e9a068951a59c99a2e2bf10b00b60b403cf12e2.
//
// Solidity: event UnpauseWithdraw()
func (_RCCStake *RCCStakeFilterer) ParseUnpauseWithdraw(log types.Log) (*RCCStakeUnpauseWithdraw, error) {
	event := new(RCCStakeUnpauseWithdraw)
	if err := _RCCStake.contract.UnpackLog(event, "UnpauseWithdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the RCCStake contract.
type RCCStakeUnpausedIterator struct {
	Event *RCCStakeUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeUnpaused represents a Unpaused event raised by the RCCStake contract.
type RCCStakeUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_RCCStake *RCCStakeFilterer) FilterUnpaused(opts *bind.FilterOpts) (*RCCStakeUnpausedIterator, error) {

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &RCCStakeUnpausedIterator{contract: _RCCStake.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_RCCStake *RCCStakeFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *RCCStakeUnpaused) (event.Subscription, error) {

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeUnpaused)
				if err := _RCCStake.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_RCCStake *RCCStakeFilterer) ParseUnpaused(log types.Log) (*RCCStakeUnpaused, error) {
	event := new(RCCStakeUnpaused)
	if err := _RCCStake.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeUpdatePoolIterator is returned from FilterUpdatePool and is used to iterate over the raw logs and unpacked data for UpdatePool events raised by the RCCStake contract.
type RCCStakeUpdatePoolIterator struct {
	Event *RCCStakeUpdatePool // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeUpdatePoolIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeUpdatePool)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeUpdatePool)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeUpdatePoolIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeUpdatePoolIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeUpdatePool represents a UpdatePool event raised by the RCCStake contract.
type RCCStakeUpdatePool struct {
	PoolId          *big.Int
	LastRewardBlock *big.Int
	TotalRCC        *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterUpdatePool is a free log retrieval operation binding the contract event 0xf5d2d72d9b25d6853afd7d0554a113b705234b6a68bb36b7f143662994632411.
//
// Solidity: event UpdatePool(uint256 indexed poolId, uint256 indexed lastRewardBlock, uint256 totalRCC)
func (_RCCStake *RCCStakeFilterer) FilterUpdatePool(opts *bind.FilterOpts, poolId []*big.Int, lastRewardBlock []*big.Int) (*RCCStakeUpdatePoolIterator, error) {

	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}
	var lastRewardBlockRule []interface{}
	for _, lastRewardBlockItem := range lastRewardBlock {
		lastRewardBlockRule = append(lastRewardBlockRule, lastRewardBlockItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "UpdatePool", poolIdRule, lastRewardBlockRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeUpdatePoolIterator{contract: _RCCStake.contract, event: "UpdatePool", logs: logs, sub: sub}, nil
}

// WatchUpdatePool is a free log subscription operation binding the contract event 0xf5d2d72d9b25d6853afd7d0554a113b705234b6a68bb36b7f143662994632411.
//
// Solidity: event UpdatePool(uint256 indexed poolId, uint256 indexed lastRewardBlock, uint256 totalRCC)
func (_RCCStake *RCCStakeFilterer) WatchUpdatePool(opts *bind.WatchOpts, sink chan<- *RCCStakeUpdatePool, poolId []*big.Int, lastRewardBlock []*big.Int) (event.Subscription, error) {

	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}
	var lastRewardBlockRule []interface{}
	for _, lastRewardBlockItem := range lastRewardBlock {
		lastRewardBlockRule = append(lastRewardBlockRule, lastRewardBlockItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "UpdatePool", poolIdRule, lastRewardBlockRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeUpdatePool)
				if err := _RCCStake.contract.UnpackLog(event, "UpdatePool", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdatePool is a log parse operation binding the contract event 0xf5d2d72d9b25d6853afd7d0554a113b705234b6a68bb36b7f143662994632411.
//
// Solidity: event UpdatePool(uint256 indexed poolId, uint256 indexed lastRewardBlock, uint256 totalRCC)
func (_RCCStake *RCCStakeFilterer) ParseUpdatePool(log types.Log) (*RCCStakeUpdatePool, error) {
	event := new(RCCStakeUpdatePool)
	if err := _RCCStake.contract.UnpackLog(event, "UpdatePool", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeUpdatePoolInfoIterator is returned from FilterUpdatePoolInfo and is used to iterate over the raw logs and unpacked data for UpdatePoolInfo events raised by the RCCStake contract.
type RCCStakeUpdatePoolInfoIterator struct {
	Event *RCCStakeUpdatePoolInfo // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeUpdatePoolInfoIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeUpdatePoolInfo)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeUpdatePoolInfo)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeUpdatePoolInfoIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeUpdatePoolInfoIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeUpdatePoolInfo represents a UpdatePoolInfo event raised by the RCCStake contract.
type RCCStakeUpdatePoolInfo struct {
	PoolId              *big.Int
	MinDepositAmount    *big.Int
	UnstakeLockedBlocks *big.Int
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterUpdatePoolInfo is a free log retrieval operation binding the contract event 0x30dffdedaa3e3b4849298233f7cd71d229956e875ab09270498c96b7cf9181fd.
//
// Solidity: event UpdatePoolInfo(uint256 indexed poolId, uint256 indexed minDepositAmount, uint256 indexed unstakeLockedBlocks)
func (_RCCStake *RCCStakeFilterer) FilterUpdatePoolInfo(opts *bind.FilterOpts, poolId []*big.Int, minDepositAmount []*big.Int, unstakeLockedBlocks []*big.Int) (*RCCStakeUpdatePoolInfoIterator, error) {

	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}
	var minDepositAmountRule []interface{}
	for _, minDepositAmountItem := range minDepositAmount {
		minDepositAmountRule = append(minDepositAmountRule, minDepositAmountItem)
	}
	var unstakeLockedBlocksRule []interface{}
	for _, unstakeLockedBlocksItem := range unstakeLockedBlocks {
		unstakeLockedBlocksRule = append(unstakeLockedBlocksRule, unstakeLockedBlocksItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "UpdatePoolInfo", poolIdRule, minDepositAmountRule, unstakeLockedBlocksRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeUpdatePoolInfoIterator{contract: _RCCStake.contract, event: "UpdatePoolInfo", logs: logs, sub: sub}, nil
}

// WatchUpdatePoolInfo is a free log subscription operation binding the contract event 0x30dffdedaa3e3b4849298233f7cd71d229956e875ab09270498c96b7cf9181fd.
//
// Solidity: event UpdatePoolInfo(uint256 indexed poolId, uint256 indexed minDepositAmount, uint256 indexed unstakeLockedBlocks)
func (_RCCStake *RCCStakeFilterer) WatchUpdatePoolInfo(opts *bind.WatchOpts, sink chan<- *RCCStakeUpdatePoolInfo, poolId []*big.Int, minDepositAmount []*big.Int, unstakeLockedBlocks []*big.Int) (event.Subscription, error) {

	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}
	var minDepositAmountRule []interface{}
	for _, minDepositAmountItem := range minDepositAmount {
		minDepositAmountRule = append(minDepositAmountRule, minDepositAmountItem)
	}
	var unstakeLockedBlocksRule []interface{}
	for _, unstakeLockedBlocksItem := range unstakeLockedBlocks {
		unstakeLockedBlocksRule = append(unstakeLockedBlocksRule, unstakeLockedBlocksItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "UpdatePoolInfo", poolIdRule, minDepositAmountRule, unstakeLockedBlocksRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeUpdatePoolInfo)
				if err := _RCCStake.contract.UnpackLog(event, "UpdatePoolInfo", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpdatePoolInfo is a log parse operation binding the contract event 0x30dffdedaa3e3b4849298233f7cd71d229956e875ab09270498c96b7cf9181fd.
//
// Solidity: event UpdatePoolInfo(uint256 indexed poolId, uint256 indexed minDepositAmount, uint256 indexed unstakeLockedBlocks)
func (_RCCStake *RCCStakeFilterer) ParseUpdatePoolInfo(log types.Log) (*RCCStakeUpdatePoolInfo, error) {
	event := new(RCCStakeUpdatePoolInfo)
	if err := _RCCStake.contract.UnpackLog(event, "UpdatePoolInfo", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeUpgradedIterator is returned from FilterUpgraded and is used to iterate over the raw logs and unpacked data for Upgraded events raised by the RCCStake contract.
type RCCStakeUpgradedIterator struct {
	Event *RCCStakeUpgraded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeUpgradedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeUpgraded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeUpgraded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeUpgradedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeUpgradedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeUpgraded represents a Upgraded event raised by the RCCStake contract.
type RCCStakeUpgraded struct {
	Implementation common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUpgraded is a free log retrieval operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_RCCStake *RCCStakeFilterer) FilterUpgraded(opts *bind.FilterOpts, implementation []common.Address) (*RCCStakeUpgradedIterator, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeUpgradedIterator{contract: _RCCStake.contract, event: "Upgraded", logs: logs, sub: sub}, nil
}

// WatchUpgraded is a free log subscription operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_RCCStake *RCCStakeFilterer) WatchUpgraded(opts *bind.WatchOpts, sink chan<- *RCCStakeUpgraded, implementation []common.Address) (event.Subscription, error) {

	var implementationRule []interface{}
	for _, implementationItem := range implementation {
		implementationRule = append(implementationRule, implementationItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "Upgraded", implementationRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeUpgraded)
				if err := _RCCStake.contract.UnpackLog(event, "Upgraded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUpgraded is a log parse operation binding the contract event 0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b.
//
// Solidity: event Upgraded(address indexed implementation)
func (_RCCStake *RCCStakeFilterer) ParseUpgraded(log types.Log) (*RCCStakeUpgraded, error) {
	event := new(RCCStakeUpgraded)
	if err := _RCCStake.contract.UnpackLog(event, "Upgraded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// RCCStakeWithdrawIterator is returned from FilterWithdraw and is used to iterate over the raw logs and unpacked data for Withdraw events raised by the RCCStake contract.
type RCCStakeWithdrawIterator struct {
	Event *RCCStakeWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *RCCStakeWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(RCCStakeWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(RCCStakeWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *RCCStakeWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *RCCStakeWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// RCCStakeWithdraw represents a Withdraw event raised by the RCCStake contract.
type RCCStakeWithdraw struct {
	User        common.Address
	PoolId      *big.Int
	Amount      *big.Int
	BlockNumber *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdraw is a free log retrieval operation binding the contract event 0x02f25270a4d87bea75db541cdfe559334a275b4a233520ed6c0a2429667cca94.
//
// Solidity: event Withdraw(address indexed user, uint256 indexed poolId, uint256 amount, uint256 indexed blockNumber)
func (_RCCStake *RCCStakeFilterer) FilterWithdraw(opts *bind.FilterOpts, user []common.Address, poolId []*big.Int, blockNumber []*big.Int) (*RCCStakeWithdrawIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}

	var blockNumberRule []interface{}
	for _, blockNumberItem := range blockNumber {
		blockNumberRule = append(blockNumberRule, blockNumberItem)
	}

	logs, sub, err := _RCCStake.contract.FilterLogs(opts, "Withdraw", userRule, poolIdRule, blockNumberRule)
	if err != nil {
		return nil, err
	}
	return &RCCStakeWithdrawIterator{contract: _RCCStake.contract, event: "Withdraw", logs: logs, sub: sub}, nil
}

// WatchWithdraw is a free log subscription operation binding the contract event 0x02f25270a4d87bea75db541cdfe559334a275b4a233520ed6c0a2429667cca94.
//
// Solidity: event Withdraw(address indexed user, uint256 indexed poolId, uint256 amount, uint256 indexed blockNumber)
func (_RCCStake *RCCStakeFilterer) WatchWithdraw(opts *bind.WatchOpts, sink chan<- *RCCStakeWithdraw, user []common.Address, poolId []*big.Int, blockNumber []*big.Int) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}
	var poolIdRule []interface{}
	for _, poolIdItem := range poolId {
		poolIdRule = append(poolIdRule, poolIdItem)
	}

	var blockNumberRule []interface{}
	for _, blockNumberItem := range blockNumber {
		blockNumberRule = append(blockNumberRule, blockNumberItem)
	}

	logs, sub, err := _RCCStake.contract.WatchLogs(opts, "Withdraw", userRule, poolIdRule, blockNumberRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(RCCStakeWithdraw)
				if err := _RCCStake.contract.UnpackLog(event, "Withdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdraw is a log parse operation binding the contract event 0x02f25270a4d87bea75db541cdfe559334a275b4a233520ed6c0a2429667cca94.
//
// Solidity: event Withdraw(address indexed user, uint256 indexed poolId, uint256 amount, uint256 indexed blockNumber)
func (_RCCStake *RCCStakeFilterer) ParseWithdraw(log types.Log) (*RCCStakeWithdraw, error) {
	event := new(RCCStakeWithdraw)
	if err := _RCCStake.contract.UnpackLog(event, "Withdraw", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
